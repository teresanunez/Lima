static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         LimaDetector.cpp
//
// description :  C++ source for the LimaDetector and its commands.
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                LimaDetector are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//          This file is generated by POGO
//    (Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State       |  dev_state()
//  Status      |  dev_status()
//  Snap        |  snap()
//  Start       |  start()
//  Stop        |  stop()
//  SetROI      |  set_roi()
//  SetBinning  |  set_binning()
//
//===================================================================



#include <LimaDetector.h>
#include <LimaDetectorClass.h>

#include <tango.h>
#include <PogoHelper.h>

#define MAX_ATTRIBUTE_STRING_LENGTH     256



namespace LimaDetector_ns
{

bool  LimaDetector::m_is_created = false;

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::LimaDetector(string &s)
//
// description :     constructor for simulated LimaDetector
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name
//
//-----------------------------------------------------------------------------
LimaDetector::LimaDetector(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

LimaDetector::LimaDetector(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
    init_device();
}

LimaDetector::LimaDetector(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::delete_device()
//
// description :     will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void LimaDetector::delete_device()
{
    INFO_STREAM << "LimaDetector::delete_device() delete device " << device_name << endl;

    //    Delete device allocated objects
    DELETE_SCALAR_ATTRIBUTE(attr_exposureTime_read);
    DELETE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read);
    DELETE_SCALAR_ATTRIBUTE(attr_sensorWidth_read);
    DELETE_SCALAR_ATTRIBUTE(attr_sensorHeight_read);
    DELETE_SCALAR_ATTRIBUTE(attr_depth_read);
    DELETE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
    DELETE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
    DELETE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_detectorType_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read);
    DELETE_SCALAR_ATTRIBUTE(attr_x_read);
    DELETE_SCALAR_ATTRIBUTE(attr_y_read);
    DELETE_SCALAR_ATTRIBUTE(attr_width_read);
    DELETE_SCALAR_ATTRIBUTE(attr_height_read);
    DELETE_SCALAR_ATTRIBUTE(attr_binning_read);

    //remove attributes from dam
    INFO_STREAM<<"Remove image dynamic attribute."<<endl;
    if(m_dam!=0)
    {
    	m_dam->remove_attributes();
    	delete m_dam;
    	m_dam = 0;
    }
    // Delete control object via the factory
    INFO_STREAM<<"Delete the main control object via the factory."<<endl;
    if(m_ct!=0)
    {
        ControlFactory::instance().reset(detectorType);
        m_ct = 0;
        m_hw = 0;
    }

    // Exit acquisition task
    INFO_STREAM<<"Exit acquisition yat::DeviceTask."<<endl;
    if (m_acquisition_task)
    {
        //- ask the task to quit
        m_acquisition_task->exit();
        //- !!!!! NEVER TRY TO <delete> a yat4tango::DeviceTask, it commits suicide 
        //- upon return of its main function (i.e. entry point)!!!!!!
        m_acquisition_task = 0;
    }

    //- remove the inner-appender
    INFO_STREAM<<"Remove the inner-appender."<<endl;
    yat4tango::InnerAppender::release(this);

}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::init_device()
//
// description :     will be called at device initialization.
//
//-----------------------------------------------------------------------------
void LimaDetector::init_device()
{
    INFO_STREAM << "LimaDetector::LimaDetector() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------

    // init some data members
    m_ct = 0;
    m_hw = 0;
    m_acquisition_task = 0;
    m_is_device_initialized = false;
    m_status_message.str("");

    //- instanciate the appender in order to manage logs
    try
    {
        //- specify both the associated device and the log buffer depth
        INFO_STREAM<<"Create the inner-appender in order to manage logs."<<endl;
        yat4tango::InnerAppender::initialize(this, 512);
    }
    catch( Tango::DevFailed& df )
    {
        ERROR_STREAM << df << endl;
        this->set_state(Tango::INIT);
        m_status_message <<"Initialization Failed :  could not instanciate the InnerAppender ! "<< endl;
        return;
    }

    //By default INIT, need to ensure that all objets are OK before set the device to STANDBY
    set_state(Tango::INIT);

    get_device_property();

    CREATE_SCALAR_ATTRIBUTE(attr_exposureTime_read,1.0);
    CREATE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read,1.0);
    CREATE_SCALAR_ATTRIBUTE(attr_sensorWidth_read);
    CREATE_SCALAR_ATTRIBUTE(attr_sensorHeight_read);
    CREATE_SCALAR_ATTRIBUTE(attr_depth_read);
    CREATE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
    CREATE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
    CREATE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
    CREATE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read,MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_detectorType_read,MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read,MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read,MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read,MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_SCALAR_ATTRIBUTE(attr_x_read);
    CREATE_SCALAR_ATTRIBUTE(attr_y_read);
    CREATE_SCALAR_ATTRIBUTE(attr_width_read);
    CREATE_SCALAR_ATTRIBUTE(attr_height_read);
    CREATE_SCALAR_ATTRIBUTE(attr_binning_read);



    //----------------------------------------------------------------------------------
    //- Create lima control object and configure acquistion parameters
    try
    {
        //- add image dynamic attribute
        //- create image dyn attr (UChar, UShort or ULong)
        INFO_STREAM<<"Add image dynamic attribute."<<endl;
        DynamicAttributeInfo dai;
        dai.dev = this;
        dai.tai.name = "image";
        dai.tai.data_format = Tango::IMAGE;

        switch(detectorPixelDepth)
        {
            case 8    :     dai.tai.data_type = Tango::DEV_UCHAR;
                break;
            case 16    :    dai.tai.data_type = Tango::DEV_USHORT;
                break;

            case 32    :    dai.tai.data_type = Tango::DEV_ULONG;
                break;
            default    :    //ERROR
							INFO_STREAM<<"Initialization Failed : DetectorPixelDepth "<<"("<<detectorPixelDepth<<") is not supported!"<< endl;
							m_status_message <<"Initialization Failed : DetectorPixelDepth "<<"("<<detectorPixelDepth<<") is not supported!"<< endl;
							m_is_device_initialized = false;
							set_state(Tango::INIT);
				return;
        }

        dai.tai.writable = Tango::READ;
        dai.tai.disp_level = Tango::OPERATOR;

        dai.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_image_callback);
        //- add the attribute to the dam
        m_dam = new DynamicAttributeManager(this);
        m_dam->add_attribute(dai);

        //- Manage LIMA logs verbose
        DebParams::setModuleFlagsNameList(debugModules);
        DebParams::setTypeFlagsNameList(debugLevels);
        DebParams::setFormatFlagsNameList(debugFormats);

        
        //- get the main object used to pilot the lima framework
        INFO_STREAM<<"Get the main control object in order to pilot the detector."<<endl;
        m_ct = ControlFactory::instance().get_control(detectorType);

        //- get interface to specific camera
        INFO_STREAM<<"Get Interface to the specific detector defined in DetectorType property."<<endl;
        m_hw = dynamic_cast<HwInterface*>(m_ct->hwInterface());
        if(m_hw==0)
        {
            INFO_STREAM<<"Initialization Failed : Unable to get the interface of camera plugin "<<"("<<detectorType<<") !"<< endl;
            m_status_message <<"Initialization Failed : Unable to get the interface of camera plugin "<<"("<<detectorType<<") !"<< endl;
            m_is_device_initialized = false;
            set_state(Tango::INIT);
            return;
        }

        //- define currentImageType of detector (16 bits, 32 bits, ...) according to "DetectorPixelDepth" device property
        INFO_STREAM<<"Define ImageType of detector (16 bits, 32 bits, ...) according to DetectorPixelDepth property."<<endl;
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);
        switch(detectorPixelDepth)
        {
            case 8    :
                hw_det_info->setCurrImageType(Bpp8);
                break;
            case 16    :
                hw_det_info->setCurrImageType(Bpp16);
                break;
            case 32    :
                hw_det_info->setCurrImageType(Bpp32);
                break;
            default    :     //ERROR
				INFO_STREAM<<"Initialization Failed : DetectorPixelDepth "<<"("<<detectorPixelDepth<<") is not supported!"<< endl;
				m_status_message <<"Initialization Failed : DetectorPixelDepth "<<"("<<detectorPixelDepth<<") is not supported!"<< endl;
				m_is_device_initialized = false;
				set_state(Tango::INIT);
				return;
        }

        //- reset image, allow to redefine type image according to  CurrentImageType of the HwDetInfoCtrlObj
        m_ct->image()->reset();

        //- reload Roi from property
        INFO_STREAM<<"Reload ROI of detector from Roi property."<<endl;
        Roi myRoi(0,0,0,0);
        if((memorizedRoi.at(0)<0) || (memorizedRoi.at(1)<0) || (memorizedRoi.at(2)<=0) || (memorizedRoi.at(3)<=0)) //Roi not initialized, then we consider all detector area as Roi
        {
            Size size;
            hw_det_info->getDetectorImageSize(size);
        	myRoi= Roi(0, 0,size.getWidth(),size.getHeight());
        }
        else 																	//Roi is initialized, then we consider all memorizedRoi property values as Roi
        {
        	myRoi = Roi(memorizedRoi.at(0), memorizedRoi.at(1),memorizedRoi.at(2),memorizedRoi.at(3));
        }
        m_ct->image()->setRoi(myRoi);

        //- reload Binning from property
        INFO_STREAM<<"Reload BIN of detector from Binning property."<<endl;
        Bin myBin(memorizedBinning, memorizedBinning);
        m_ct->image()->setBin(myBin);

        //- Set default nb frames of acquisition at start-up
        INFO_STREAM<<"Set default nb. frames of acquisition at start-up to "<<attr_nbFrames_write<<"."<<endl;
        m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

        //- define parameters of ctSaving object used to store image in files
        INFO_STREAM<<"Define parameters used to save image into a file."<<endl;
        ImageType image_type;
        hw_det_info->getCurrImageType(image_type);
        m_saving_par.directory         = fileTargetPath;
        m_saving_par.prefix            = filePrefix;
        m_saving_par.imageType         = image_type;
        m_saving_par.indexFormat       = fileIndexPattern;
        m_saving_par.nextNumber        = 1;
        m_saving_par.savingMode        = CtSaving::Manual;
        m_saving_par.framesPerFile     = fileNbFrames;
        m_saving_par.nbframes          = attr_nbFrames_write;

        transform(fileFormat.begin(), fileFormat.end(),fileFormat.begin(), ::toupper);

        if (fileFormat.compare("NXS") == 0)
        {
            m_saving_par.fileFormat = CtSaving::NXS;
            m_saving_par.suffix = ".nxs";
        }
        else if(fileFormat.compare("EDF") == 0)
        {
            m_saving_par.fileFormat = CtSaving::EDF;
            m_saving_par.suffix = ".edf";
        }
        else if(fileFormat.compare("CBF") == 0)
        {
            m_saving_par.fileFormat = CtSaving::CBFFormat;
            m_saving_par.suffix = ".cbf";
        }
        else
        {
            m_saving_par.fileFormat = CtSaving::RAW;
            m_saving_par.suffix = ".raw";
        }
        m_ct->saving()->setParameters(m_saving_par);

        //video stuff
        INFO_STREAM<<"Initialize video mode according to VideoMode property."<<endl;
        std::map<string,VideoMode> 	mMyVideoMode;
        mMyVideoMode["Y8"] 			= Y8;
        mMyVideoMode["Y16"] 		= Y16;
        mMyVideoMode["Y32"] 		= Y32;
        mMyVideoMode["Y64"] 		= Y64;
        mMyVideoMode["RGB555"] 		= RGB555;
        mMyVideoMode["RGB565"] 		= RGB565;
        ////TODO resolve compatibility with tango
        //mMyVideoMode["RGB24"] 	= lima::RGB24;
        mMyVideoMode["RGB32"] 		= RGB32;
        mMyVideoMode["BGR24"] 		= BGR24;
        mMyVideoMode["BGR32"] 		= BGR32;
        mMyVideoMode["BAYER_RG8"] 	= BAYER_RG8;
        mMyVideoMode["BAYER_RG16"] 	= BAYER_RG16;
        mMyVideoMode["I420"] 		= I420;
        mMyVideoMode["YUV411"] 		= YUV411;
        mMyVideoMode["YUV422"] 		= YUV422;
        mMyVideoMode["YUV444"] 		= YUV444;

        transform(detectorVideoMode.begin(), detectorVideoMode.end(),detectorVideoMode.begin(), ::toupper);
        if(detectorVideoMode.compare("NONE") ==0)
        {/*NOP*/
        }
        else
        {
            map<string,VideoMode>::iterator it = mMyVideoMode.find(detectorVideoMode);
    		if(it!= mMyVideoMode.end())
    		{
    			m_ct->video()->setMode(it->second);
    		}
    		else
    		{
    			ERROR_STREAM<<"Initialization Failed : VideoMode "<<"("<<detectorVideoMode<<") is not supported!"<< endl;
    			m_status_message<<"Initialization Failed : VideoMode "<<"("<<detectorVideoMode<<") is not supported!"<< endl;
    			m_is_device_initialized = false;
    			set_state(Tango::INIT);
    			return;
    		}

        }
        //- Activate video mode in order to get notification associated to image acquisition
        INFO_STREAM<<"Activate video mode in order to get notification for each acquired image."<< endl;
        m_ct->video()->setActive(true);
    }
    catch(Exception& e)
    {
    	ERROR_STREAM<<"Initialization Failed : "<<e.getErrMsg()<<endl;
        m_status_message <<"Initialization Failed : "<<e.getErrMsg( )<< endl;
        m_is_device_initialized = false;
        set_state(Tango::INIT);
        return;
    }
    catch(...)
    {
    	ERROR_STREAM<<"Initialization Failed : UNKNOWN"<<endl;
        m_status_message <<"Initialization Failed : UNKNOWN"<< endl;
        set_state(Tango::INIT);
        m_is_device_initialized = false;
        return;
    }

    //----------------------------------------------------------------------------------
    //- Create acquisition Task, State = INIT if Task could not be created !
    INFO_STREAM<<"Create acquisition yat::DeviceTask."<<endl;
    if(create_acquisition_task() == false )
    {
        set_state(Tango::INIT);
        m_is_device_initialized = false;
        return;
    }

    //- Ensure to call this, only when sub device is already created by ClassFactory
    if(LimaDetector::m_is_created)
    {
        //- force Init() on the specific sub device.
        INFO_STREAM<<"Force Initialization on the specific sub device."<<endl;
        ControlFactory::instance().init_specific_device(detectorType);
    }

    // everything seems ok
    m_is_device_initialized = true;
    LimaDetector::m_is_created = true;
    set_state(Tango::STANDBY);
    this->dev_state();

}


//+----------------------------------------------------------------------------
//
// method :         LimaDetector::get_device_property()
//
// description :     Read the device properties from database.
//
//-----------------------------------------------------------------------------
void LimaDetector::get_device_property()
{
    //    Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //    Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DetectorDescription"));
	dev_prop.push_back(Tango::DbDatum("DetectorType"));
	dev_prop.push_back(Tango::DbDatum("DetectorPixelDepth"));
	dev_prop.push_back(Tango::DbDatum("DetectorVideoMode"));
	dev_prop.push_back(Tango::DbDatum("FileFormat"));
	dev_prop.push_back(Tango::DbDatum("FilePrefix"));
	dev_prop.push_back(Tango::DbDatum("FileIndexPattern"));
	dev_prop.push_back(Tango::DbDatum("FileNbFrames"));
	dev_prop.push_back(Tango::DbDatum("FileTargetPath"));
	dev_prop.push_back(Tango::DbDatum("DebugModules"));
	dev_prop.push_back(Tango::DbDatum("DebugLevels"));
	dev_prop.push_back(Tango::DbDatum("DebugFormats"));
	dev_prop.push_back(Tango::DbDatum("MemorizedRoi"));
	dev_prop.push_back(Tango::DbDatum("MemorizedBinning"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	LimaDetectorClass	*ds_class =
		(static_cast<LimaDetectorClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize DetectorDescription from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorDescription;
	else {
		//	Try to initialize DetectorDescription from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorDescription;
	}
	//	And try to extract DetectorDescription value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorDescription;

	//	Try to initialize DetectorType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorType;
	else {
		//	Try to initialize DetectorType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorType;
	}
	//	And try to extract DetectorType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorType;

	//	Try to initialize DetectorPixelDepth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorPixelDepth;
	else {
		//	Try to initialize DetectorPixelDepth from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorPixelDepth;
	}
	//	And try to extract DetectorPixelDepth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorPixelDepth;

	//	Try to initialize DetectorVideoMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorVideoMode;
	else {
		//	Try to initialize DetectorVideoMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorVideoMode;
	}
	//	And try to extract DetectorVideoMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorVideoMode;

	//	Try to initialize FileFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileFormat;
	else {
		//	Try to initialize FileFormat from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileFormat;
	}
	//	And try to extract FileFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileFormat;

	//	Try to initialize FilePrefix from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  filePrefix;
	else {
		//	Try to initialize FilePrefix from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  filePrefix;
	}
	//	And try to extract FilePrefix value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filePrefix;

	//	Try to initialize FileIndexPattern from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileIndexPattern;
	else {
		//	Try to initialize FileIndexPattern from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileIndexPattern;
	}
	//	And try to extract FileIndexPattern value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileIndexPattern;

	//	Try to initialize FileNbFrames from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileNbFrames;
	else {
		//	Try to initialize FileNbFrames from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileNbFrames;
	}
	//	And try to extract FileNbFrames value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileNbFrames;

	//	Try to initialize FileTargetPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileTargetPath;
	else {
		//	Try to initialize FileTargetPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileTargetPath;
	}
	//	And try to extract FileTargetPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileTargetPath;

	//	Try to initialize DebugModules from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugModules;
	else {
		//	Try to initialize DebugModules from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugModules;
	}
	//	And try to extract DebugModules value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugModules;

	//	Try to initialize DebugLevels from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugLevels;
	else {
		//	Try to initialize DebugLevels from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugLevels;
	}
	//	And try to extract DebugLevels value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugLevels;

	//	Try to initialize DebugFormats from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugFormats;
	else {
		//	Try to initialize DebugFormats from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugFormats;
	}
	//	And try to extract DebugFormats value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugFormats;

	//	Try to initialize MemorizedRoi from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedRoi;
	else {
		//	Try to initialize MemorizedRoi from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedRoi;
	}
	//	And try to extract MemorizedRoi value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedRoi;

	//	Try to initialize MemorizedBinning from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedBinning;
	else {
		//	Try to initialize MemorizedBinning from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedBinning;
	}
	//	And try to extract MemorizedBinning value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedBinning;



    //    End of Automatic code generation
    //------------------------------------------------------------------
    vector<string> myVector;

    create_property_if_empty(dev_prop,"This is my simulator","DetectorDescription");
    create_property_if_empty(dev_prop,"SimulatorCCD","DetectorType");
    create_property_if_empty(dev_prop,"16","DetectorPixelDepth");
    create_property_if_empty(dev_prop,"NONE","DetectorVideoMode");
    create_property_if_empty(dev_prop,"NXS","FileFormat");
    create_property_if_empty(dev_prop,"Image","FilePrefix");
    create_property_if_empty(dev_prop,"%06d","FileIndexPattern");
    create_property_if_empty(dev_prop,"1","FileNbFrames");
    create_property_if_empty(dev_prop,"./data","FileTargetPath");

    myVector.clear();
    myVector.push_back("Hardware");
    myVector.push_back("Control");
    myVector.push_back("Common");
    myVector.push_back("Camera");
    create_property_if_empty(dev_prop,myVector,"DebugModules");

    myVector.clear();
    myVector.push_back("Fatal");
    myVector.push_back("Error");
    myVector.push_back("Warning");
    create_property_if_empty(dev_prop,myVector,"DebugLevels");

    myVector.clear();
    myVector.push_back("DateTime");
    myVector.push_back("Module");
    myVector.push_back("Type");
    create_property_if_empty(dev_prop,myVector,"DebugFormats");



	myVector.clear();
	myVector.push_back("-1");
	myVector.push_back("-1");
	myVector.push_back("-1");
	myVector.push_back("-1");
	create_property_if_empty(dev_prop,myVector,"MemorizedRoi");
	
	create_property_if_empty(dev_prop,"1","MemorizedBinning");

}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::always_executed_hook()
//
// description :     method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void LimaDetector::always_executed_hook()
{

}
//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_attr_hardware
//
// description :     Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "LimaDetector::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //    Add your own code here
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorDescription
//
// description :     Extract real attribute values for detectorDescription acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorDescription(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_detectorDescription(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        strcpy(*attr_detectorDescription_read , detectorDescription.c_str());
        attr.set_value(attr_detectorDescription_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorDescription"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorType
//
// description :     Extract real attribute values for detectorType acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorType(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_detectorType(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);

        string str_detector_type;
        hw_det_info->getDetectorType(str_detector_type);

        strcpy(*attr_detectorType_read , str_detector_type.c_str());
        attr.set_value(attr_detectorType_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorType"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorType"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_detectorModel
//
// description :     Extract real attribute values for detectorModel acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorModel(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_detectorModel(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);

        string str_detector_model;
        hw_det_info->getDetectorModel(str_detector_model);

        strcpy(*attr_detectorModel_read , str_detector_model.c_str());
        attr.set_value(attr_detectorModel_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorModel"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorModel"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_sensorWidth
//
// description :     Extract real attribute values for sensorWidth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_sensorWidth(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_sensorWidth(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);
        Size size;
        hw_det_info->getDetectorImageSize(size);

        *attr_sensorWidth_read = size.getWidth();
        attr.set_value(attr_sensorWidth_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorWidth"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorWidth"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_sensorHeight
//
// description :     Extract real attribute values for sensorHeight acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_sensorHeight(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_sensorHeight(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);
        Size size;
        hw_det_info->getDetectorImageSize(size);

        *attr_sensorHeight_read = size.getHeight();
        attr.set_value(attr_sensorHeight_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorHeight"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorHeight"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_Depth
//
// description :     Extract real attribute values for Depth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_depth(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_depth(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        HwDetInfoCtrlObj *hw_det_info;
        m_hw->getHwCtrlObj(hw_det_info);
        ImageType image_type;
        hw_det_info->getCurrImageType(image_type);

        FrameDim frame_dim;
        *attr_depth_read = frame_dim.getImageTypeBpp(image_type);
        attr.set_value(attr_depth_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_depth"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_depth"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_triggerMode
//
// description :     Extract real attribute values for triggerMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_triggerMode(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_triggerMode(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        TrigMode trig_mode = IntTrig;
        m_ct->acquisition()->getTriggerMode(trig_mode);

        if (trig_mode == IntTrig)
            strcpy(*attr_triggerMode_read, "INTERNAL_SINGLE");
        else if (trig_mode == ExtTrigSingle)
            strcpy(*attr_triggerMode_read, "EXTERNAL_SINGLE");
        else if (trig_mode == ExtTrigMult)
            strcpy(*attr_triggerMode_read, "EXTERNAL_MULTI");
        else if (trig_mode == ExtGate)
            strcpy(*attr_triggerMode_read, "EXTERNAL_GATE");
        else
            strcpy(*attr_triggerMode_read, "ERROR");

        attr.set_value(attr_triggerMode_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_triggerMode"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_triggerMode"));
    }

}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_triggerMode
//
// description :     Write triggerMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_triggerMode(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_triggerMode(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        m_trigger_mode = *attr_triggerMode_read;
        string previous = m_trigger_mode;
        attr.get_write_value(attr_triggerMode_write);
        string current = attr_triggerMode_write;
        if(current.compare("INTERNAL_SINGLE")!=0 && current.compare("EXTERNAL_SINGLE")!=0 && current.compare("EXTERNAL_MULTI")!=0 && current.compare("EXTERNAL_GATE")!=0)
        {
            m_trigger_mode = previous;
            attr_triggerMode_write = new char [m_trigger_mode.size()+1];
            strcpy (attr_triggerMode_write, m_trigger_mode.c_str());

            Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
                                            (const char*) ("Available Trigger Modes are: \n- INTERNAL_SINGLE \n- EXTERNAL_SINGLE \n- EXTERNAL_MULTI \n- EXTERNAL_GATE"),
                                            (const char*) ("LimaDetector::write_triggerMode"));
        }

        //- THIS IS AN AVAILABLE TRIGER MODE
        m_trigger_mode = attr_triggerMode_write;

        TrigMode trig_mode = IntTrig;
        if(m_trigger_mode.compare("INTERNAL_SINGLE")==0)
            trig_mode = IntTrig;
        else if (m_trigger_mode.compare("EXTERNAL_SINGLE")==0)
            trig_mode = ExtTrigSingle;
        else if (m_trigger_mode.compare("EXTERNAL_MULTI")==0)
            trig_mode = ExtTrigMult;
        else //m_trigger_mode.compare("EXTERNAL_GATE")==0
            trig_mode = ExtGate;

        m_ct->acquisition()->setTriggerMode(trig_mode);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_triggerMode"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_triggerMode"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_acquisitionMode
//
// description :     Extract real attribute values for acquisitionMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_acquisitionMode(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_acquisitionMode(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        AcqMode acq_mode = Single;
        m_ct->acquisition()->getAcqMode(acq_mode);
        if (acq_mode == Single)
            strcpy(*attr_acquisitionMode_read, "SINGLE");
        else if (acq_mode == Accumulation)
            strcpy(*attr_acquisitionMode_read, "ACCUMULATION");
        else
            strcpy(*attr_acquisitionMode_read, "ERROR");

        attr.set_value(attr_acquisitionMode_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_acquisitionMode"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_acquisitionMode
//
// description :     Write acquisitionMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_acquisitionMode(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_acquisitionMode(Tango::WAttribute &attr) entering... "<< endl;

    try
    {
        string previous = m_acquisition_mode;
        attr.get_write_value(attr_acquisitionMode_write);
        string current = attr_acquisitionMode_write;
        if(current.compare("SINGLE")!=0 && current.compare("ACCUMULATION")!=0)
        {
            m_acquisition_mode = previous;
            attr_acquisitionMode_write = new char [m_acquisition_mode.size()+1];
            strcpy (attr_acquisitionMode_write, m_acquisition_mode.c_str());

            Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
                                            (const char*) ("Available Acquisition Modes are: \n- SINGLE \n- ACCUMULATION"),
                                            (const char*) ("LimaDetector::write_acquisitionMode"));
        }

        //- THIS IS AN AVAILABLE ACQUISITION MODE
        m_acquisition_mode = attr_acquisitionMode_write;
        if(m_acquisition_mode.compare("SINGLE")==0)
        {
            m_ct->acquisition()->setAcqMode(Single);
        }

        if(m_acquisition_mode.compare("ACCUMULATION")==0)
        {
            m_ct->acquisition()->setAcqMode(Accumulation);
        }

        if(previous.compare(m_acquisition_mode)==0)//if acquisition mode is the same than the previous one -> no need to recreate again image dynmaic attribute
        	return;//Nothing to do .

        //////*** Everytime we change acquisition mode, we have to adapt dynamic image attribute type ***//////
        //this is due to Lima/control/Accumulation.cpp module implementation: in ACCUMULATION image type is always 32 bits

        //- reset image number (this will disable the refresh of image attribute)
        m_ct->resetStatus(false);

        //remove attributes from dam
        INFO_STREAM<<"Remove image dynamic attribute."<<endl;
        if(m_dam!=0)
        {
        	m_dam->remove_attributes();
        	delete m_dam;
        	m_dam = 0;
        }

        //- add image dynamic attribute
		//- create image dyn attr (UChar, UShort or ULong)
		INFO_STREAM<<"Add image dynamic attribute."<<endl;
		DynamicAttributeInfo dai;
		dai.dev = this;
		dai.tai.name = "image";
		dai.tai.data_format = Tango::IMAGE;


        if(m_acquisition_mode.compare("SINGLE")==0)
        {
            switch(detectorPixelDepth)
            {
                case 8    :     dai.tai.data_type = Tango::DEV_UCHAR;
                    break;
                case 16    :    dai.tai.data_type = Tango::DEV_USHORT;
                    break;

                case 32    :    dai.tai.data_type = Tango::DEV_ULONG;
                    break;
            }
        }

        if(m_acquisition_mode.compare("ACCUMULATION")==0)
        {
            dai.tai.data_type = Tango::DEV_ULONG;//force to 32 bits if ACCUMULATION MODE, this is due to Lima core.
        }

        dai.tai.writable = Tango::READ;
        dai.tai.disp_level = Tango::OPERATOR;
        dai.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_image_callback);

        //- add the attribute to the dam
        m_dam = new DynamicAttributeManager(this);
        m_dam->add_attribute(dai);
        //////*******************************************************************************************//////
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_acquisitionMode"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_acquisitionMode"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_exposureTime
//
// description :     Extract real attribute values for exposureTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureTime(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_exposureTime(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        double exposure;
        m_ct->acquisition()->getAcqExpoTime(exposure);
        *attr_exposureTime_read = (Tango::DevDouble)(exposure*1000.0);//exposure USER OUTPUT is in millisec
        attr.set_value(attr_exposureTime_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureTime"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureTime"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_exposureTime
//
// description :     Write exposureTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureTime(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_exposureTime(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        attr.get_write_value(attr_exposureTime_write);
        m_ct->acquisition()->setAcqExpoTime((double)(attr_exposureTime_write/1000.0));//exposure USER INPUT is in millisec
        m_ct->video()->setExposure((double)(attr_exposureTime_write/1000.0));//exposure USER INPUT is in millisec
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureTime"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureTime"));
    }
}


//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_exposureAccTime
//
// description :     Extract real attribute values for exposureAccTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureAccTime(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_exposureAccTime(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        if(m_acquisition_mode.compare("ACCUMULATION")==0)
        {
            double exposure;
            m_ct->acquisition()->getAccExpoTime(exposure);
            *attr_exposureAccTime_read = (Tango::DevDouble)(exposure*1000.0);
            attr.set_value(attr_exposureAccTime_read);
        }
        else
        {
            attr.set_quality(Tango::ATTR_INVALID);
        }
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureAccTime"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureAccTime"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_exposureAccTime
//
// description :     Write exposureAccTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureAccTime(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_exposureAccTime(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        attr.get_write_value(attr_exposureAccTime_write);
        m_ct->acquisition()->setAccMaxExpoTime((double)(attr_exposureAccTime_write/1000.0));

    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureAccTime"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureAccTime"));
    }
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_x
//
// description : 	Extract real attribute values for x acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_x(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_x(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_x_read = roi.getTopLeft().x;
		attr.set_value(attr_x_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_x"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_x"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_y
//
// description : 	Extract real attribute values for y acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_y(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_y(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_y_read = roi.getTopLeft().y;
		attr.set_value(attr_y_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_y"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_y"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_width
//
// description : 	Extract real attribute values for width acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_width(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_width(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_width_read = roi.getSize().getWidth();
		attr.set_value(attr_width_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_width"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_width"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_height
//
// description : 	Extract real attribute values for height acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_height(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_height(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		Roi roi;
		m_ct->image()->getRoi(roi);
		*attr_height_read = roi.getSize().getHeight();
		attr.set_value(attr_height_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_height"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_height"));
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_binning
//
// description : 	Extract real attribute values for binning acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_binning(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_binning(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		Bin bin;
		m_ct->image()->getBin(bin);
		*attr_binning_read = bin.getX();
		attr.set_value(attr_binning_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_binning"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_binning"));
	}
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_nbFrames
//
// description :     Extract real attribute values for nbFrames acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_nbFrames(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_nbFrames(Tango::Attribute &attr) entering... "<< endl;
    int nbframes = 0;
    try
    {
        m_ct->acquisition()->getAcqNbFrames(nbframes);
        *attr_nbFrames_read = nbframes;
        attr.set_value(attr_nbFrames_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_nbFrames"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_nbFrames"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_nbFrames
//
// description :     Write nbFrames attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_nbFrames(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_nbFrames(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        attr.get_write_value(attr_nbFrames_write);
        m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_nbFrames"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_nbFrames"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_currentFrame
//
// description :     Extract real attribute values for currentFrame acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_currentFrame(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_currentFrame(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        *attr_currentFrame_read =       m_hw->getNbHwAcquiredFrames();////get_last_image_counter()+1;
        attr.set_value(attr_currentFrame_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_currentFrame"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_currentFrame"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::get_last_image_counter
//
//-----------------------------------------------------------------------------
int LimaDetector::get_last_image_counter(void)
{
    DEBUG_STREAM << "LimaDetector::get_last_image_counter()"<<endl;
	long long last_image_counter = 0;
    try
    {
    	m_ct->video()->getLastImageCounter(last_image_counter);
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::get_last_image_counter"));
	}
	return (last_image_counter);
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_image_callback()
//
// description :
//
//-----------------------------------------------------------------------------
void LimaDetector::read_image_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "LimaDetector::read_image_callback()"<<endl;//  << cbd.dya->get_name() << endl;
    try
    {
    	if(!m_ct || !m_hw)
            return; //NOP
    	int counter = get_last_image_counter();

    	if(counter >= 0)
    	{
        	DEBUG_STREAM<<"last_image_counter -> "<<counter<<endl;
    		m_ct->video()->getLastImage(m_last_image);
			if(m_last_image.buffer()!=0)
			{
				switch (cbd.dya->get_tango_data_type())
				{
					//8 bits
					DEBUG_STREAM<<"image->set_value() : DevUChar"<<endl;
					case  TangoTraits<Tango::DevUChar>::type_id :     cbd.tga->set_value(	(Tango::DevUChar*)m_last_image.buffer(),
																							m_last_image.width(),//- width
																							m_last_image.height()//- height
																						);
					break;

					//16 bits
					DEBUG_STREAM<<"image->set_value() : DevUShort"<<endl;
					case  TangoTraits<Tango::DevUShort>::type_id :     cbd.tga->set_value( 	(Tango::DevUShort*)m_last_image.buffer(),
																							m_last_image.width(),//- width
																							m_last_image.height()//- height
																						);
					break;

					//32 bits
					DEBUG_STREAM<<"image->set_value() : DevULong"<<endl;
					case  TangoTraits<Tango::DevULong>::type_id :     cbd.tga->set_value( 	(Tango::DevULong*)m_last_image.buffer(),
																							m_last_image.width(),//- width
																							m_last_image.height()//- height
																						);
					break;

					//ERROR : resolution not supported
					default    :
			            //- throw exception
			            Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
			                                            (const char*) ("Tango data type of image DynamicAttribute, is not supported!\n"),
			                                            (const char*) ("LimaDetector::read_image_callback"));
					break;
				}
			}
    	}
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                static_cast<const char*> (string(df.errors[0].desc).c_str()),
                static_cast<const char*> ("LimaDetector::read_image_callback"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            static_cast<const char*> ("TANGO_DEVICE_ERROR"),
            static_cast<const char*> (e.getErrMsg().c_str()),
            static_cast<const char*> ("LimaDetector::read_image_callback"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::read_fileGeneration
//
// description :     Extract real attribute values for fileGeneration acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_fileGeneration(Tango::Attribute &attr)
{
    DEBUG_STREAM << "LimaDetector::read_fileGeneration(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        CtSaving::SavingMode mode;
        m_ct->saving()->getSavingMode(mode);
        if(mode == CtSaving::AutoFrame)
            *attr_fileGeneration_read = true;
        else
            *attr_fileGeneration_read = false;

        attr.set_value(attr_fileGeneration_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_fileGeneration"));
    }
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::write_fileGeneration
//
// description :     Write fileGeneration attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_fileGeneration(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "LimaDetector::write_fileGeneration(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        attr.get_write_value(attr_fileGeneration_write);
        if(attr_fileGeneration_write == true)
            m_ct->saving()->setSavingMode(CtSaving::AutoFrame);
        else
            m_ct->saving()->setSavingMode(CtSaving::Manual);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_fileGeneration"));
    }
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::snap
 *
 *	description:	method to execute "Snap"
 *	Starts the acquisition of a number of frames equal to  'nbFrames' attribute value.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::snap()
{
    DEBUG_STREAM << "LimaDetector::snap(): entering... !" << endl;

    //    Add your own code to control device here
    try
    {
        if(attr_nbFrames_write == 0)
        {
            //- throw exception
            Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
                                            (const char*) ("Snap command is not Available when 'nbFrames' is 0\nUse Start command to diplay a 'video' stream.\n"),
                                            (const char*) ("LimaDetector::snap"));
        }

        m_saving_par.nbframes         = attr_nbFrames_write;
        if(attr_fileGeneration_write)
        {
            m_saving_par.savingMode        = CtSaving::AutoFrame;
        }
        else
        {
            m_saving_par.savingMode        = CtSaving::Manual;
        }
        m_ct->saving()->setParameters(m_saving_par);

        //- in SNAP mode, we request attr_nbFrames_write frames
        m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

        //- print some infos
        print_acq_conf();

        yat::Message* msg = yat::Message::allocate( DEVICE_SNAP_MSG, DEFAULT_MSG_PRIORITY, true );
        m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        m_status_message.str("");
        m_status_message<<string(df.errors[0].desc).c_str()<<endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::snap"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message.str("");
        m_status_message<<e.getErrMsg().c_str()<<endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::snap"));
    }
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::start
 *
 *	description:	method to execute "Start"
 *	Starts a "video/live" acquisition of an infinite number of frames.<br>
 *	It is not allowed to generate files in this mode.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::start()
{
    DEBUG_STREAM << "LimaDetector::start(): entering... !" << endl;

    //    Add your own code to control device here
    try
    {
        if(attr_fileGeneration_write == true)
        {
            //- throw exception
            Tango::Except::throw_exception( (const char*) ("CONFIGURATION_ERROR"),
                                            (const char*) ("Start command is not Available when 'fileGeneration' is enabled\n"),
                                            (const char*) ("LimaDetector::start"));
        }

        m_saving_par.nbframes         = 0;

        //- force NO saving files in continuous mode !
        m_saving_par.savingMode        = CtSaving::Manual;
        m_ct->saving()->setParameters(m_saving_par);

        //- in START "LIVE" mode, we request (0) as frames number
        m_ct->acquisition()->setAcqNbFrames(0);

        //- print some infos
        print_acq_conf();
        yat::Message* msg = yat::Message::allocate( DEVICE_START_MSG, DEFAULT_MSG_PRIORITY, true );
        m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima

     	m_ct->video()->startLive();
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::start"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::start"));
    }
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::stop
 *
 *	description:	method to execute "Stop"
 *	Stop current acquisition.
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::stop()
{
    DEBUG_STREAM << "LimaDetector::stop(): entering... !" << endl;

    //    Add your own code to control device here
    try
    {
    	m_ct->video()->stopLive();
    	yat::Message* msg = yat::Message::allocate( DEVICE_STOP_MSG, DEFAULT_MSG_PRIORITY, true );
        m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::stop"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::stop"));
    }
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::set_roi
 *
 *	description:	method to execute "SetROI"
 *	Define a Region of Interest . (OriginX, OriginY, Width, Height)
 *
 * @param	argin	[origin_x, origin_y, width, height]
 *
 */
//+------------------------------------------------------------------
void LimaDetector::set_roi(const Tango::DevVarLongArray *argin)
{
    DEBUG_STREAM << "LimaDetector::set_roi(): entering... !" << endl;

    //    Add your own code to control device here
    try
    {
        if(argin->length()!= 4)
        {
            //- throw exception
            Tango::Except::throw_exception( (const char*) ("TANGO_DEVICE_ERROR"),
                                            (const char*) ("Invalid number of parameters. Check input parameters (x, y, width, height)\n"),
                                            (const char*) ("LimaDetector::set_roi"));
        }

        unsigned long x      = (*argin)[0];
        unsigned long y      = (*argin)[1];
        unsigned long width  = (*argin)[2];
        unsigned long height = (*argin)[3];

        //- reset image number (this will disable the refresh of image attribute)
        m_ct->resetStatus(false);

        //- set the new ROI
        Roi roi(Point(x, y), Size(width,height));
        m_ct->image()->setRoi(roi);

        //- update Roi property
        vector<short> myVector;
    	myVector.clear();
    	myVector.push_back(roi.getTopLeft().x);
    	myVector.push_back(roi.getTopLeft().y);
    	myVector.push_back(roi.getSize().getWidth());
    	myVector.push_back(roi.getSize().getHeight());
		store_value_as_property(myVector,"MemorizedRoi");
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::set_roi"));
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::set_roi"));
    }

}


//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::set_binning
 *
 *	description:	method to execute "SetBinning"
 *	Define a binning for the image. <br>
 *	Availables values are  :<br>
 *	1->binning(1,1)<br>
 *	2->binning(2,2)<br>
 *	3->binning(3,3)<br>
 *	4->binning(4,4)<br>
 *	8->binning(8,8)<br>
 *
 * @param	argin	
 *
 */
//+------------------------------------------------------------------
void LimaDetector::set_binning(Tango::DevUShort argin)
{
	DEBUG_STREAM << "LimaDetector::set_binning(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		if(argin != 1 && argin !=2 && argin!=3 && argin!=4 && argin!=8)
		{
			//- throw exception
			Tango::Except::throw_exception( (const char*) ("TANGO_DEVICE_ERROR"),
											(const char*) ("Availables values are : 1, 2, 3, 4 or 8\n"),
											(const char*) ("LimaDetector::set_binning"));
		}

		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);

		//- set the new BIN
		Bin bin(argin, argin);
		m_ct->image()->setBin(bin);
		store_value_as_property(argin,"MemorizedBinning");
		//- reset image number (this will disable the refresh of image attribute)
		m_ct->resetStatus(false);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::set_binning"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::set_binning"));
	}
}


//+------------------------------------------------------------------
/**
 *    method:    LimaDetector::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState LimaDetector::dev_state()
{
    Tango::DevState    argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "LimaDetector::dev_state(): entering... !" << endl;

    //    Add your own code to control device here
    stringstream    DeviceStatus;
    DeviceStatus     << "";
    Tango::DevState DeviceState    = Tango::STANDBY;
    //if error during init_device
    if(!m_is_device_initialized)
    {
        DeviceState        = Tango::INIT;
        DeviceStatus    << m_status_message.str();
        DeviceStatus    << endl;
    }
    else
    {
        // if error in acquisition task
        if(m_acquisition_task->get_state()==Tango::FAULT)
        {
            DeviceState=Tango::FAULT;//FAULT
            DeviceStatus<<m_acquisition_task->get_status()<<endl;
        }
        else
        {
            CtControl::Status status;
            m_ct->getStatus(status);
            if (status.AcquisitionStatus == lima::AcqReady)
            {
                HwInterface::StatusType state;
                m_hw->getStatus(state); 
                if(state.acq == AcqRunning && state.det == DetExposure)
                {
                    DeviceState=Tango::RUNNING;
                    DeviceStatus<<"Acquisition is Running ...\n"<<endl;
                }
                else if(state.acq == AcqFault && state.det == DetFault)
                {                 
                    DeviceState=Tango::INIT;//INIT
                    DeviceStatus<<"Acquisition is in Init\n"<<endl;
                }
                else if(state.acq == AcqFault && state.det == DetIdle)
                {                 
                    DeviceState=Tango::FAULT;//FAULT
                    DeviceStatus<<"Acquisition is in Fault\n"<<endl;
                }
                else
                {
                    DeviceState=Tango::STANDBY;
                    DeviceStatus<<"Waiting for Request ...\n"<<endl;
                }
            }
            else if(status.AcquisitionStatus == lima::AcqRunning)
            {           
                DeviceState=Tango::RUNNING;
                DeviceStatus<<"Acquisition is Running ...\n"<<endl;
            }
            else
            {      
                HwInterface::StatusType state;
                m_hw->getStatus(state); 
                if(state.acq == AcqFault && state.det == DetFault)
                {                 
                    DeviceState=Tango::INIT;//INIT
                    DeviceStatus<<"Acquisition is in Init\n"<<endl;
                }
                else
                {
                  DeviceState=Tango::FAULT;//FAULT
                  DeviceStatus<<"Acquisition is in Fault\n"<<endl;
                }
            }              
        }
        //DeviceStatus<< m_status_message.str();
        //DeviceStatus<<endl;
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}

//+----------------------------------------------------------------------------
//
// method :         LimaDetector::create_acquisition_task
//
//-----------------------------------------------------------------------------
bool LimaDetector::create_acquisition_task(void)
{
    DEBUG_STREAM << "LimaDetector::CreateAcquisitionTask()" << endl;
    //- Prepare Acquisition task
    try
    {
        //---------------------------------------------------------------------
        //- Create the task
        m_acquisition_task = new AcquisitionTask(this);

        //- prepare the conf to be passed to the task
        m_acq_conf.ct                = m_ct;
        m_acq_conf.file_target_path  = fileTargetPath;        //property, no need to refresh on each START_MSG

        //- create an INIT msg to pass it some data (Conf)
        yat::Message* msg = yat::Message::allocate( yat::TASK_INIT, INIT_MSG_PRIORITY, true );
        msg->attach_data( m_acq_conf );
        m_acquisition_task->go( msg ); //- post the INIT msg
    }
    catch( yat::Exception& ex )
    {
        //throw_devfailed( ex );
        m_status_message <<"Initialization Failed : "<<endl;
        for(unsigned i = 0; i < ex.errors.size(); i++)
        {
            m_status_message <<ex.errors[i].desc<<endl;
        }
        ex.dump();
        return false;
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM<<df<<endl;
        m_status_message << "Initialization Failed : "<<endl;
        for(unsigned i = 0; i < df.errors.length(); i++)
        {
            m_status_message << df.errors[i].desc<<endl;
        }
        return false;
    }
    catch(...)
    {
        ERROR_STREAM <<"Initialization Failed : UNKNOWN"<<endl;
        m_status_message <<"Initialization Failed : UNKNOWN"<<endl;
        return false;
    }

    //---------------------------------------------------------------------
    //everything seems OK
    return true;
}



//+----------------------------------------------------------------------------
//
// method :         LimaDetector::print_acq_conf
//
//-----------------------------------------------------------------------------
void LimaDetector::print_acq_conf(void)
{
	INFO_STREAM<<"\n"<<endl;
	INFO_STREAM<<"-------------------------------------------------------"<<endl;
    VideoMode videomode;
    m_ct->video()->getMode(videomode);
    INFO_STREAM<<"pixelDepth\t  = "         <<detectorPixelDepth<<endl;
    INFO_STREAM<<"videoMode\t  = "          <<videomode<<endl;
    INFO_STREAM<<"triggerMode\t  = "        <<m_trigger_mode<<endl;
    INFO_STREAM<<"acquisitionMode\t  = "    <<m_acquisition_mode<<endl;
    INFO_STREAM<<"exposureTime\t  = "       <<attr_exposureTime_write<<endl;
    INFO_STREAM<<"exposureAccTime= "       <<attr_exposureAccTime_write<<endl;
    INFO_STREAM<<"directory\t  = "          <<m_saving_par.directory<<endl;
    INFO_STREAM<<"prefix\t  = "             <<m_saving_par.prefix<<endl;
    INFO_STREAM<<"suffix\t  = "             <<m_saving_par.suffix<<endl;
    INFO_STREAM<<"imageType\t  = "          <<m_saving_par.imageType<<endl;
    INFO_STREAM<<"indexFormat\t  = "        <<m_saving_par.indexFormat<<endl;
    INFO_STREAM<<"framesPerFile\t  = "      <<m_saving_par.framesPerFile<<endl;
    INFO_STREAM<<"nbframes\t  = "           <<m_saving_par.nbframes<<endl;
    INFO_STREAM<<"fileGeneration\t  = "     <<attr_fileGeneration_write<<endl;

    //display BIN
	Bin bin;
	m_ct->image()->getBin(bin);
	INFO_STREAM <<"Bin\t  = ("<<bin.getX()<<" , "<<bin.getX()<<")"<<endl;

    //display ROI
    Roi roi;
	m_ct->image()->getRoi(roi);
	INFO_STREAM <<"Roi\t  = [" <<roi.getTopLeft().x<<" , "<<roi.getTopLeft().y <<" , "<<roi.getSize().getWidth()<<" , "<<roi.getSize().getHeight()<<"]"<<endl;
    INFO_STREAM<<"-------------------------------------------------------"<<endl;
}

/*-------------------------------------------------------------------------
//       LimaDetector::store_value_as_property
/-------------------------------------------------------------------------*/
template <class T>
void LimaDetector::store_value_as_property (T value, string property_name)
{
    Tango::DbDatum current_value(property_name);
    current_value << value;
    Tango::DbData db_data;
    db_data.push_back(current_value);
    try
    {
        get_db_device()->put_property(db_data);
    }
    catch(Tango::DevFailed &df)
    {
        string message= "Error in storing " + property_name + " in Configuration DataBase ";
        LOG_ERROR((message));
        ERROR_STREAM<<df<<endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                    static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                    static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::store_value_as_property"));
    }

}

/*-------------------------------------------------------------------------
//       LimaDetector::create_property_if_empty
/-------------------------------------------------------------------------*/
template <class T>
void LimaDetector::create_property_if_empty(Tango::DbData& dev_prop,T value,string property_name)
{
    int iPropertyIndex = FindIndexFromPropertyName(dev_prop,property_name);
    if (iPropertyIndex == -1) return;
    if (dev_prop[iPropertyIndex].is_empty())
    {
        Tango::DbDatum current_value(dev_prop[iPropertyIndex].name);
        current_value << value;
        Tango::DbData db_data;
        db_data.push_back(current_value);

        try
        {
            get_db_device()->put_property(db_data);
        }
        catch(Tango::DevFailed &df)
        {
            string message= "Error in storing " + property_name + " in Configuration DataBase ";
            LOG_ERROR((message));
            ERROR_STREAM<<df<<endl;
            //- rethrow exception
            Tango::Except::re_throw_exception(df,
                        static_cast<const char*> ("TANGO_DEVICE_ERROR"),
                        static_cast<const char*> (string(df.errors[0].desc).c_str()),
                        static_cast<const char*> ("LimaDetector::create_property_if_empty"));
        }
    }
}

/*-------------------------------------------------------------------------
//       LimaDetector::FindIndexFromPropertyName
/-------------------------------------------------------------------------*/
int LimaDetector::FindIndexFromPropertyName(Tango::DbData& dev_prop, string property_name)
{
    size_t iNbProperties = dev_prop.size();
    unsigned int i;
    for (i=0;i<iNbProperties;i++)
    {
        string sPropertyName(dev_prop[i].name);
        if (sPropertyName == property_name) return i;
    }
    if (i == iNbProperties) return -1;
    return i;
}

}	//	namespace
