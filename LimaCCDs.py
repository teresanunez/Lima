############################################################################
# This file is part of LImA, a Library for Image Acquisition
#
# Copyright (C) : 2009-2011
# European Synchrotron Radiation Facility
# BP 220, Grenoble 38043
# FRANCE
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
############################################################################
#=============================================================================
#
# file :        LimaCCDs.py
#
# description : Python source for the LimaCCDs and its commands. 
#               The class is derived from Device. It represents the
#               CORBA servant object which will be accessed from the
#               network. All commands which can be executed on the
#               LimaCCDs are implemented in this file.
#
# project :    TANGO Device Server
#
# copyleft :    European Synchrotron Radiation Facility
#        BP 220, Grenoble 38043
#        FRANCE
#
#=============================================================================
#        This file is generated by seb
#
#      (c) - BLISS - ESRF
#=============================================================================
#

import sys,os,glob
import PyTango
import weakref
import itertools
import numpy
import struct


# Before loading Lima.Core, must find out the version the plug-in
# was compiled with - horrible hack ...
if 'linux' in sys.platform:
    from EnvHelper import setup_lima_env
    setup_lima_env(sys.argv)

from AttrHelper import CallableReadEnum,CallableWriteEnum

from Lima import Core

import plugins
import camera
try:
    import EdfFile
except ImportError:
    EdfFile = None
    
TacoSpecificDict = {}
TacoSpecificName = []

VerboseLevel2TypeFlags = {
    0: ['Fatal'],
    1: ['Error'],
    2: ['Warning'],
    3: ['Trace'],
    4: ['Funct', 'Param', 'Return']
    }

class LimaCCDs(PyTango.Device_4Impl) :

    Core.DEB_CLASS(Core.DebModApplication, 'LimaCCDs')
    _debugModuleList = ["None",
                        "Common",
                        "Hardware",
                        "HardwareSerial",
                        "Control",
                        "Espia",
                        "EspiaSerial",
                        "Focla",
                        "Camera",
                        "CameraCom",
                        "Test",
                        "Application"]
    
    _debugTypeList = ["Fatal",
                      "Error",
                      "Warning",
                      "Trace",
                      "Funct",
                      "Param",
                      "Return",
                      "Always"]
    
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,*args) :
        PyTango.Device_4Impl.__init__(self,*args)
        self.__className2deviceName = {}
        self.init_device()
        self.__lima_control = None

 	self.__key_header_delimiter = '='
        self.__entry_header_delimiter = '\n'
        self.__image_number_header_delimiter = ';'
	self.__readImage_frame_number = 0
        self.__configInit = False
       
#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def delete_device(self) :
        try:
            m = __import__('camera.%s' % (self.LimaCameraType),None,None,'camera.%s' % (self.LimaCameraType))
        except ImportError:
            pass
        else:
            try:
                m.close_interface()
            except AttributeError: pass

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def init_device(self) :
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        self.__className2deviceName = get_sub_devices()
        dataBase = PyTango.Database()

        TacoSpecificName.append(self.LimaCameraType)
        
        try:
            m = __import__('camera.%s' % (self.LimaCameraType),None,None,'camera.%s' % (self.LimaCameraType))
        except ImportError:
            import traceback
            traceback.print_exc()
            self.set_state(PyTango.DevState.FAULT)
        else:
            properties = {}
            try:
                specificClass,specificDevice = m.get_tango_specific_class_n_device()
            except AttributeError: pass
            else:
                typeFlagsNameList = []
                for l in range(verboseLevel + 1):
                    typeFlagsNameList += VerboseLevel2TypeFlags.get(l, [])
                Core.DebParams.setTypeFlagsNameList(typeFlagsNameList)

                util = PyTango.Util.instance()
                deviceName = self.__className2deviceName.get(specificDevice.__name__,None)
                if deviceName:
                    propertiesNames = dataBase.get_device_property_list(deviceName,"*")
                    for pName in propertiesNames.value_string:
                        key,value = dataBase.get_device_property(deviceName,pName).popitem()
                        if len(value) == 1:
                            value = value[0]
                        properties[key] = value
            
            self.__control = m.get_control(**properties)
            _set_control_ref(weakref.ref(self.__control))

        try:
            nb_thread = int(self.NbProcessingThread)
        except ValueError:
            pass
        else:
            Core.Processlib.PoolThreadMgr.get().setNumberOfThread(nb_thread)

        self.__accThresholdCallback = None
	
	accThresholdCallbackModule = self.AccThresholdCallbackModule
	if not accThresholdCallbackModule:
	# if NO property accThresholdCallbackModule has been set the member var. is set to []
	    pass
        else:
            try:
                m = __import__('plugins.%s' % (accThresholdCallbackModule),None,None,
                               'plugins.%s' % (accThresholdCallbackModule))
            except ImportError:
                deb.Error("Couldn't import plugins.%s" % accThresholdCallbackModule)
            else:
                try:
                    func = getattr(m,'get_acc_threshold_callback')
                    self.__accThresholdCallback = func()
                    acc = self.__control.accumulation()
                    acc.registerThresholdCallback(self.__accThresholdCallback)
                except AttributeError:
                    deb.Error("Accumulation threshold plugins module don't have get_acc_threshold_callback function")

        #Tango Enum to Lima Enum
        self.__Prefix2SubClass = {'acc' : self.__control.acquisition,
                                  'acq' : self.__control.acquisition,
                                  'shutter' : self.__control.shutter,
                                  'saving' : self.__control.saving,
                                  'image' : self.__control.image,
                                  'video' : self.__control.video}

        self.__Attribute2FunctionBase = {'acq_trigger_mode':'TriggerMode',
                                         'saving_overwrite_policy' : 'OverwritePolicy',
                                         'saving_format' : 'Format',
                                         'shutter_mode' : 'Mode',
					 'image_rotation':'Rotation',
                                         'video_mode':'Mode'}
            
        self.__ShutterMode = {'MANUAL': Core.ShutterManual,
                              'AUTO_FRAME': Core.ShutterAutoFrame,
                              'AUTO_SEQUENCE': Core.ShutterAutoSequence}
        
        self.__AcqMode = {'SINGLE': Core.Single,
                          'CONCATENATION': Core.Concatenation,
                          'ACCUMULATION': Core.Accumulation}

        try:
            self.__AccTimeMode = {'LIVE' : Core.CtAcquisition.Live,
                                  'REAL' : Core.CtAcquisition.Real}
        except AttributeError:          # Core too Old
            self.__AccTimeMode = {}
        
        self.__SavingFormat = {'RAW' : Core.CtSaving.RAW,
                               'EDF' : Core.CtSaving.EDF,
                               'CBF' : Core.CtSaving.CBFFormat,
                               'TIFF' : Core.CtSaving.TIFFFormat}

	try:
	     self.__SavingFormat['EDFGZ'] = Core.CtSaving.EDFGZ
             self.__SavingFormatDefaultSuffix[Core.CtSaving.EDFGZ] = '.edfgz'
	except AttributeError:
	     pass

        self.__SavingFormatDefaultSuffix = {Core.CtSaving.RAW : '.raw',
                                            Core.CtSaving.EDF : '.edf',
                                            Core.CtSaving.CBFFormat : '.cbf',
                                            Core.CtSaving.TIFFFormat : '.tiff'}

        self.__SavingMode = {'MANUAL' : Core.CtSaving.Manual,
                             'AUTO_FRAME' : Core.CtSaving.AutoFrame,
                             'AUTO_HEADER' : Core.CtSaving.AutoHeader}

        self.__SavingOverwritePolicy = {'ABORT' : Core.CtSaving.Abort,
                                        'OVERWRITE' : Core.CtSaving.Overwrite,
                                        'APPEND' : Core.CtSaving.Append}

        self.__AcqTriggerMode = {'INTERNAL_TRIGGER' : Core.IntTrig,
                                 'EXTERNAL_TRIGGER' : Core.ExtTrigSingle,
                                 'EXTERNAL_TRIGGER_MULTI' : Core.ExtTrigMult,
                                 'EXTERNAL_GATE' : Core.ExtGate,
                                 'EXTERNAL_START_STOP' : Core.ExtStartStop}
	try:
	    self.__AcqTriggerMode['INTERNAL_TRIGGER_MULTI'] = Core.IntTrigMult
	except AttributeError:
	    pass
	try:
	    self.__AcqTriggerMode['EXTERNAL_TRIGGER_READOUT'] = Core.ExtTrigReadout
	except AttributeError:
	    pass

        try:
            self.__ImageRotation = {'NONE' : Core.Rotation_0,
                                    '90' : Core.Rotation_90,
                                    '180' : Core.Rotation_180,
                                    '270' : Core.Rotation_270}
        except AttributeError:
            pass

        try:
            self.__VideoMode = {'Y8'         : Core.Y8,
                                'Y16'        : Core.Y16,
                                'Y32'        : Core.Y32,
                                'Y64'        : Core.Y64,
                                'RGB555'     : Core.RGB555,
                                'RGB565'     : Core.RGB565,
                                'RGB24'      : Core.RGB24,
                                'RGB32'      : Core.RGB32,
                                'BGR24'      : Core.BGR24,
                                'BGR32'      : Core.BGR32,
                                'BAYER RG8'  : Core.BAYER_RG8,
                                'BAYER RG16' : Core.BAYER_RG16,
                                'I420'       : Core.I420,
                                'YUV411'     : Core.YUV411,
                                'YUV422'     : Core.YUV422,
                                'YUV444'     : Core.YUV444}
        except AttributeError:
            import traceback
            traceback.print_exc()
	#INIT display shared memory
	try:
	    self.__shared_memory_names = ['LimaCCds',self.LimaCameraType]
	    shared_memory = self.__control.display()
	    shared_memory.setNames(*self.__shared_memory_names)
	except AttributeError:
	    self.__shared_memory_names = ['','']

        
    def __getattr__(self,name) :
        if name.startswith('is_') and name.endswith('_allowed') :
            split_name = name.split('_')[1:-1]
            attr_name = ''.join([x.title() for x in split_name])
            dict_name = '_' + self.__class__.__name__ + '__' + attr_name
            d = getattr(self,dict_name,None)
            func = _allowed
            if d is not None:
                if not d:
                    func = _not_allowed
            self.__dict__[name] = func
            return func
        elif name.startswith('read_') or name.startswith('write_') :
            split_name = name.split('_')[1:]
            attr_name = ''.join([x.title() for x in split_name])
            dict_name = '_' + self.__class__.__name__ + '__' + attr_name
            d = getattr(self,dict_name,None)
            getObjectFunc = self.__Prefix2SubClass.get(split_name[0],None)
            attr_name = self.__Attribute2FunctionBase.get('_'.join(split_name),attr_name)
            if d and getObjectFunc:
                obj = getObjectFunc()
                if name.startswith('read_') :
                    functionName = 'get' + attr_name
                    function2Call = getattr(obj,functionName)
                    callable_obj = CallableReadEnum(d,function2Call)
                else:
                    functionName = 'set' + attr_name
                    function2Call = getattr(obj,functionName)
                    callable_obj = CallableWriteEnum('_'.join(split_name),
                                                     d,function2Call)
                self.__dict__[name] = callable_obj
                return callable_obj
        
        raise AttributeError('LimaCCDs has no attribute %s' % name)

    def always_executed_hook(self) :
        if not self.__configInit:
            self.__configInit = True
            #Configuration mgt
            config_file_path = self.ConfigurationFilePath
            config_default_name = self.ConfigurationDefaultName

            self.__configDefaultActiveFlag = False
            try:
                config = self.__control.config()
            except AttributeError:
                pass
            else:
                config.setFilename(config_file_path)
                if os.access(config_file_path,os.R_OK):
                    try:
                        config.load()
                        config.apply(config_default_name)
                        self.__configDefaultActiveFlag = True
                    except Core.Exception:
                        pass


#==================================================================
#
#    LimaCCDs read/write attribute methods
#
#==================================================================

    ## @brief Read the Lima Type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_lima_type(self,attr) :        
        value  = self.LimaCameraType	
        attr.set_value(value)

    ## @brief Read the Camera Type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_type(self,attr) :        
        interface = self.__control.hwInterface()
	det_info = interface.getHwCtrlObj(Core.HwCap.DetInfo)
	value = det_info.getDetectorType()
        attr.set_value(value)

    ## @brief Read the Camera Model
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_model(self,attr) :        
	interface = self.__control.hwInterface()
	det_info = interface.getHwCtrlObj(Core.HwCap.DetInfo)
	value = det_info.getDetectorModel() 
	attr.set_value(value)
        
    ## @brief Read the Camera pixelsize
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_pixelsize(self,attr) :        
	interface = self.__control.hwInterface()
	det_info = interface.getHwCtrlObj(Core.HwCap.DetInfo)
	value = det_info.getPixelSize() 
	attr.set_value(value)
        
    ## @brief get the status of the acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_status(self,attr) :
        status = self.__control.getStatus()
        state2string = {Core.AcqReady : "Ready",
                        Core.AcqRunning : "Running",
                        Core.AcqFault : "Fault"}
        try:
            state2string[Core.AcqConfig] = "Configuration"
        except AttributeError:
            pass

        attr.set_value(state2string.get(status.AcquisitionStatus,"?"))
    ## @brief get the errir message when acq_status is in Fault stat
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_status_fault_error(self,attr) :
        status = self.__control.getStatus()
        state2string = {Core.CtControl.NoError : "No error",
                        Core.CtControl.SaveUnknownError : "Saving: unknown error",
                        Core.CtControl.SaveOpenError : "Saving: file open error",
                        Core.CtControl.SaveCloseError : "Saving: file close error",
                        Core.CtControl.SaveAccessError : "Saving: access error",
                        Core.CtControl.SaveOverwriteError : "Saving: overwrite error",
                        Core.CtControl.SaveDiskFull : "Saving: disk full",
                        Core.CtControl.SaveOverun : "Saving: overun",
                        Core.CtControl.ProcessingOverun : "Processing: overun",
                        Core.CtControl.CameraError : "Camera: error"}
        attr.set_value(state2string.get(status.Error,"?"))
        
    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_nb_frames(self,attr) :
        acquisition = self.__control.acquisition()
        nb_frames = acquisition.getAcqNbFrames()
        attr.set_value(nb_frames)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_nb_frames(self,attr) :
        data = attr.get_write_value()
        acquisition = self.__control.acquisition()
        acquisition.setAcqNbFrames(data)
        
    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_expo_time(self,attr) :
        acquisition = self.__control.acquisition()
        expo_time = acquisition.getAcqExpoTime()
        attr.set_value(expo_time)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_expo_time(self,attr) :
        data = attr.get_write_value()
        acquisition = self.__control.acquisition()
        acquisition.setAcqExpoTime(data)
        
    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_max_expo_time(self,attr) :        
	acq = self.__control.acquisition()

        value = acq.getAccMaxExpoTime()
	if value is None: value = -1
	
        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_max_expo_time(self,attr) :
        data = attr.get_write_value()
	acq = self.__control.acquisition()
        acq.setAccMaxExpoTime(data)

    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_concat_nb_frames(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getConcatNbFrames()
        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_concat_nb_frames(self,attr) :
        data = attr.get_write_value()
	acq = self.__control.acquisition()
        acq.setConcatNbFrames(data)

    ## @brief Read calculated accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_expo_time(self,attr) :        
	acq = self.__control.acquisition()

        value = acq.getAccExpoTime()
	if value is None: value = -1
	
        attr.set_value(value)
	
    ## @brief Read calculated accumulation number of frames
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_nb_frames(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccNbFrames()
	if value is None: value = -1
	
        attr.set_value(value)

    ## @brief Read calculated accumulation dead time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_dead_time(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccDeadTime()

        attr.set_value(value)

    ## @brief Read calculated accumulation live time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_live_time(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccLiveTime()
	
        attr.set_value(value)

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_active(self,attr) :        
	acc = self.__control.accumulation()
        value = acc.getActive()
	
        attr.set_value(value)

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_active(self,attr) :            
        data = attr.get_write_value()

	acc = self.__control.accumulation()
        acc.setActive(data)

    ## @brief Read saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_threshold(self,attr) :        
	acc = self.__control.accumulation()
        value = acc.getPixelThresholdValue()
	
        attr.set_value(value)

    ## @brief Set saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_threshold(self,attr) :        
        data = attr.get_write_value()

	acc = self.__control.accumulation()
        acc.setPixelThresholdValue(data)

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_cblevel(self,attr) :
        if self.__accThresholdCallback is not None:
            attr.set_value(self.__accThresholdCallback.m_max)
        else:
            msg = "Accumulation threshold plugins not loaded"
            deb.Error(msg)
            raise Exception, msg

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_cblevel(self,attr) :        
        data = attr.get_write_value()
        if self.__accThresholdCallback is not None:
            self.__accThresholdCallback.m_max = data
        else:
            msg = "Accumulation threshold plugins not loaded"
            deb.Error(msg)
            raise Exception, msg
        
    ## @brief Read latency time 
    #
    @Core.DEB_MEMBER_FUNCT
    def read_latency_time(self,attr) :
        acq = self.__control.acquisition()

        value = acq.getLatencyTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write Latency time 
    #
    @Core.DEB_MEMBER_FUNCT
    def write_latency_time(self,attr) :
        data = attr.get_write_value()
        acq = self.__control.acquisition()

        acq.setLatencyTime(data)

    ## @brief Read the valid latency and exposure valid ranges
    #
    @Core.DEB_MEMBER_FUNCT
    def read_valid_ranges(self,attr) :        
        interface = self.__control.hwInterface()
	sync = interface.getHwCtrlObj(Core.HwCap.Sync)
	ranges = sync.getValidRanges()
        attr.set_value([ranges.min_exp_time,ranges.max_exp_time,ranges.min_lat_time,ranges.max_lat_time])


    ## @brief Read image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_roi(self,attr) :
        image = self.__control.image()
        roi = image.getRoi()
        point = roi.getTopLeft()
        size = roi.getSize()
        
        attr.set_value([point.x,point.y,
                        size.getWidth(),size.getHeight()])

    ## @brief Write image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_roi(self,attr) :
        data = attr.get_write_value()
        image = self.__control.image()
        roi = Core.Roi(*data)
        image.setRoi(roi)

    ## @brief Read image type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_sizes(self,attr) :
        imageType2NbBytes = {
            Core.Bpp8 : (1,0) ,
            Core.Bpp8S : (1,1) ,
            Core.Bpp10 : (2,0) ,
            Core.Bpp10S : (2,1) ,
            Core.Bpp12 : (2,0) ,
            Core.Bpp12S : (2,1) ,
            Core.Bpp14 : (2,0) ,
            Core.Bpp14S : (2,1) , 
            Core.Bpp16 : (2,0),
            Core.Bpp16S : (2,1),
            Core.Bpp32 : (4,0) ,
            Core.Bpp32S : (4,1)
            }        
        image = self.__control.image()
        imageType = image.getImageType()
        dim = image.getImageDim()
        depth, signed = imageType2NbBytes.get(imageType,(0,0))
        sizes = [signed, depth, dim.getSize().getWidth(), dim.getSize().getHeight()]
        
        attr.set_value(sizes)

    ## @brief Read image type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_type(self,attr) :
        imageType2String = {
            Core.Bpp8 : "Bpp8" ,
            Core.Bpp8S : "Bpp8S" ,
            Core.Bpp10 : "Bpp10" ,
            Core.Bpp10S : "Bpp10S" ,
            Core.Bpp12 : "Bpp12" ,
            Core.Bpp12S : "Bpp12S" ,
            Core.Bpp14 : "Bpp14" ,
            Core.Bpp14S : "Bpp14S" , 
            Core.Bpp16 : "Bpp16" ,
            Core.Bpp16S : "Bpp16S" ,
            Core.Bpp32 : "Bpp32" ,
            Core.Bpp32S : "Bpp32S"
            }
        image = self.__control.image()
        imageType = image.getImageType()
        stringType = imageType2String.get(imageType,"?")
                
        attr.set_value(stringType)

    ## @brief Read image width
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_width(self,attr) :
        image = self.__control.image()
 	dim = image.getImageDim()
                        
        attr.set_value(dim.getSize().getWidth())

    ## @brief Read image height
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_height(self,attr) :
        image = self.__control.image()
 	dim = image.getImageDim()
                        
        attr.set_value(dim.getSize().getHeight())

    ## @brief Read image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_bin(self,attr) :
        image = self.__control.image()
        binValues = image.getBin()
                        
        attr.set_value([binValues.getX(),
                        binValues.getY()],2)

    ## @brief Write image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_bin(self,attr) :
        data = attr.get_write_value()

        image = self.__control.image()
        binValue = Core.Bin(*data)
        image.setBin(binValue)
    

    ## @brief Read image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_flip(self,attr) :
        image = self.__control.image()
        flip = image.getFlip()
        attr.set_value([flip.x,flip.y],2)

    ## @brief Write image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_flip(self,attr) :
        data = attr.get_write_value()
        flip = Core.Flip(*data)
        image = self.__control.image()
        image.setFlip(flip)

    ## @brief Read common header
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_common_header(self,attr) :
        saving = self.__control.saving()
        header = saving.getCommonHeader()
        headerArr = ['%s%s%s' % (k,self.__key_header_delimiter,v) for k,v in header.iteritems()]
        attr.set_value(headerArr,len(headerArr))

    ## @brief Write common header
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_common_header(self,attr) :
        data = attr.get_write_value()
        header = dict([x.split(self.__key_header_delimiter) for x in data])
        saving = self.__control.saving()
        saving.setCommonHeader(header)

    ## @brief Read header delimiter
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_header_delimiter(self,attr) :
        attr.set_value([self.__key_header_delimiter,
                        self.__entry_header_delimiter,
                        self.__image_number_header_delimiter],3)

    ##@brief Write header delimiter
    #
    def write_saving_header_delimiter(self,attr) :
        data = attr.get_write_value()
        self.__key_header_delimiter = data[0]
        self.__entry_header_delimiter = data[1]
        self.__image_number_header_delimiter = data[2]

    def read_saving_index_format(self,attr) :
	saving = self.__control.saving()
	params = saving.getParameters()
	attr.set_value(params.indexFormat)

    def write_saving_index_format(self,attr) :
	data = attr.get_write_value()
	saving = self.__control.saving()
	params = saving.getParameters()
	params.indexFormat = data
	saving.setParameters(params)

    ## @brief last image acquired
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_acquired(self,attr) :
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastImageAcquired
        attr.set_value(value)

    ## @brief last base image acquired
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_base_image_ready(self,attr) :
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastBaseImageReady
        attr.set_value(value)

    
    ## @brief Read last image ready
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_ready(self,attr) :
        status = self.__control.getStatus()
	img_counters= status.ImageCounters

        value = img_counters.LastImageReady

        attr.set_value(value)

    ## @brief last counter ready
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_counter_ready(self,attr) :
        status = self.__control.getStatus()
	img_counters= status.ImageCounters

        value = img_counters.LastCounterReady

        attr.set_value(value)

    ## @brief Read last image saved
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_saved(self,attr) :
        status = self.__control.getStatus()
        img_counters= status.ImageCounters

        value = img_counters.LastImageSaved
        if value is None: value = -1

        attr.set_value(value)

    ## @brief this flag is true just after
    #  the detector readout.
    #
    # This attribute should be use
    #  to test is client can re-trigger an other image
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_image(self,attr) :
        interface = self.__control.hwInterface()
        status = interface.getStatus()
        attr.set_value(status.det == Core.DetIdle)

    ## @brief this flag is true when acquisition is finished
    #
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_acq(self,attr) :
        status = self.__control.getStatus()
        attr.set_value(status.AcquisitionStatus == Core.AcqReady)

    
    ## @brief read write statistic
    #
    @Core.DEB_MEMBER_FUNCT
    def read_write_statistic(self,attr) :
        saving = self.__control.saving()
        stat = saving.getWriteTimeStatistic()
        if not len(stat) :
            attr.set_value([-1],1)
        else:
            attr.set_value(stat,len(stat))
	

    ## @brief Write current shutter state if in manual mode
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_manual_state(self,attr) :
        state = attr.get_write_value()
        if state not in ["OPEN", "CLOSE", "NO_MANUAL_MODE"]:
            raise Exception, "Invalid shutter state"

        shutter = self.__control.shutter()
	if (shutter.hasCapability() and 
            shutter.getModeList().count(Core.ShutterManual) and
            shutter.getMode() == Core.ShutterManual and
            state in ["OPEN", "CLOSE"]):
            if shutter.getState(): state = "OPEN"
            else: state = "CLOSED"
	else:
            raise Exception, "Shutter not in manual mode"

    ## @brief Read current shutter state if in manual mode
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_manual_state(self,attr) :
        shutter = self.__control.shutter()

	if (shutter.hasCapability() and 
            shutter.getModeList().count(Core.ShutterManual) and
            shutter.getMode() == Core.ShutterManual):
            if shutter.getState(): state = "OPEN"
            else: state = "CLOSED"
	else:
            state = "NO_MANUAL_MODE"
			
        attr.set_value(state)

    ## @brief Read shutter open time
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_open_time(self,attr) :
        shutter = self.__control.shutter()

        value = shutter.getOpenTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write shutter open time 
    # 
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_open_time(self,attr) :
        data = attr.get_write_value()
        shutter = self.__control.shutter()

        shutter.setOpenTime(data)

    ## @brief Read shutter close time
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_close_time(self,attr) :
        shutter = self.__control.shutter()

        value = shutter.getCloseTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write shutter close time 
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_close_time(self,attr) :
        data = attr.get_write_value()
        shutter = self.__control.shutter()
        
        shutter.setCloseTime(data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_directory(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getDirectory())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_directory(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()
        newDirectory = data
        if os.access(newDirectory,os.W_OK|os.X_OK) :
            saving.setDirectory(newDirectory)
        else:
            PyTango.Except.throw_exception('Access Error',\
                                           'Directory %s is not writtable'%(newDirectory),\
                                           'LimaCCD Class')

    @Core.DEB_MEMBER_FUNCT
    def read_saving_prefix(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getPrefix())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_prefix(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()
        prefix = data

        directory = saving.getDirectory()
        suffix = saving.getSuffix()
        overwritePolicy = saving.getOverwritePolicy()
        if overwritePolicy == Core.CtSaving.Abort:
            matchFiles = glob.glob(os.path.join(directory,'%s*%s' % (prefix,suffix)))
            lastnumber = _getLastFileNumber(prefix,suffix,matchFiles)
        else:
            lastnumber = -1
        saving.setPrefix(prefix)
        saving.setNextNumber(lastnumber + 1)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_suffix(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getSuffix())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_suffix(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setSuffix(data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_next_number(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getNextNumber())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_next_number(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setNextNumber(data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_frame_per_file(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getFramePerFile())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_frame_per_file(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setFramesPerFile(data)
        
    ## @brief Change the saving Format
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_format(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()

        value = _getDictValue(self.__SavingFormat,data.upper())
	if value is None:
            PyTango.Except.throw_exception('WrongData',\
                                           'Wrong value %s: %s'%('saving_format',data.upper()),\
                                           'LimaCCD Class')
        else:
            saving.setFormat(value)
            defaultSuffix = self.__SavingFormatDefaultSuffix.get(value,'.unknown')
            saving.setSuffix(defaultSuffix)

    ## @brief Read the frame per file
    #
    @Core.DEB_MEMBER_FUNCT
    def read_frame_per_file(self,attr) :
        saving = self.__control.saving()

        value = saving.getFramePerFile()
        attr.set_value(value)

    ## @brief Change the number of saving frame per file
    #
    @Core.DEB_MEMBER_FUNCT
    def write_frame_per_file(self,attr) :
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setFramesPerFile(data)

    ##@biref Read possible modules
    #
    def read_debug_modules_possible(self,attr) :
        attr.set_value(LimaCCDs._debugModuleList,len(LimaCCDs._debugModuleList))
        
    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_modules(self,attr) :
        NameList = Core.DebParams.getModuleFlagsNameList()
        attr.set_value(NameList,len(NameList))

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_modules(self,attr) :
        data = attr.get_write_value()
        Core.DebParams.setModuleFlagsNameList(data)
    
    ##@biref Read possible modules
    #
    def read_debug_types_possible(self,attr) :
        attr.set_value(LimaCCDs._debugTypeList,len(LimaCCDs._debugTypeList))
        
    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_types(self,attr) :
        NameList = Core.DebParams.getTypeFlagsNameList()

        if NameList:
            attr.set_value(NameList,len(NameList))
        else:
            attr.set_value([''],1)

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_types(self,attr) :
        data = attr.get_write_value()
        Core.DebParams.setTypeFlagsNameList(data)

    def read_video_active(self,attr) :
        video = self.__control.video()
        attr.set_value(video.isActive())

    def write_video_active(self,attr) :
        video = self.__control.video()
        data = attr.get_write_value()
        video.setActive(data)

    def read_video_live(self,attr) :
        video = self.__control.video()
        attr.set_value(video.getLive())

    def write_video_live(self,attr) :
        video = self.__control.video()
        data = attr.get_write_value()
        if data :
            video.startLive()
        else:
            video.stopLive()

    def read_video_exposure(self,attr) :
        video = self.__control.video()
        attr.set_value(video.getExposure())

    def write_video_exposure(self,attr) :
        video = self.__control.video()
        data = attr.get_write_value()
        video.setExposure(data)

    def read_video_gain(self,attr) :
        video = self.__control.video()
        attr.set_value(video.getGain())

    def write_video_gain(self,attr) :
        video = self.__control.video()
        data = attr.get_write_value()
        video.setGain(data)

    def read_video_bin(self,attr) :
        video = self.__control.video()
        binValue = video.getBin()

        attr.set_value([binValue.getX(),
                        binValue.getY()],2)

    def write_video_bin(self,attr) :
        data = attr.get_write_value()
        
        video = self.__control.video()
        binValue = Core.Bin(*data)
        video.setBin(binValue)


    def read_video_roi(self,attr) :
        video = self.__control.video()
        roi = video.getRoi()
        point = roi.getTopLeft()
        size = roi.getSize()
        
        attr.set_value([point.x,point.y,
                        size.getWidth(),size.getHeight()])

    def write_video_roi(self,attr) :
        data = attr.get_write_value()
        video = self.__control.video()
        roi = Core.Roi(*data)
        video.setRoi(roi)

    def read_video_last_image(self,attr) :
        video = self.__control.video()
        lastImage = video.getLastImage()
        VIDEO_HEADER_FORMAT = '!IHHqiiHHHH'
        videoheader = struct.pack(
            VIDEO_HEADER_FORMAT,
            0x5644454f,                           # Magic
            1,                                    # header version
            lastImage.mode(),                     # image mode (Y8,Y16...)
            lastImage.frameNumber(),              # frame number
            lastImage.width(),                    # width
            lastImage.height(),                   # height
            ord(struct.pack('=H',1)[-1]),         # endianness
            struct.calcsize(VIDEO_HEADER_FORMAT), # header size
            0,0)                                  # padding

        self._videoStr = videoheader + lastImage.buffer()
        attr.set_value("VIDEO_IMAGE",self._videoStr)

    def read_video_last_image_counter(self,attr) :
        video = self.__control.video()
        attr.set_value(video.getLastImageCounter())

    def read_plugin_type_list(self,attr) :
        className2deviceName = get_sub_devices()
        attr.set_value([x.lower().replace('deviceserver','') for x in className2deviceName.keys()])

    def read_plugin_list(self,attr) :
        returnList = []
        for key,value in get_sub_devices().iteritems():
            returnList.append(key.lower().replace('deviceserver',''))
            returnList.append(value)
        attr.set_value(returnList)

    def read_shared_memory_names(self,attr) :
        attr.set_value(self.__shared_memory_names)

    def write_shared_memory_names(self,attr) :
        self.__shared_memory_names = attr.get_write_value()
        shared_memory = self.__control.display()
        shared_memory.setNames(*self.__shared_memory_names)

    def read_shared_memory_active(self,attr):
        attr.set_value(self.__control.display().isActive())

    def write_shared_memory_active(self,attr):
        data = attr.get_write_value()
        self.__control.display().setActive(data)

    def read_config_available_module(self,attr) :
        config = self.__control.config()
        attr.set_value(config.getAvailableModule())

    def read_config_available_name(self,attr) :
        config = self.__control.config()
        attr.set_value(config.getAlias())
        
#==================================================================
#
#    LimaCCDs command methods
#
#==================================================================
#------------------------------------------------------------------
#    getAttrStringValueList command:
#
#    Description: return a list of authorized values if any
#    argout: DevVarStringArray   
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def getAttrStringValueList(self, attr_name):
        valueList=[]
        if attr_name == 'shutter_mode':
            shutter = self.__control.shutter()
            if shutter.hasCapability():
                #Depending of the camera only a subset of the mode list can be supported
                values = shutter.getModeList()
                valueList = [_getDictKey(self.__ShutterMode,val) for val in values]
        elif attr_name == 'video_mode':
            video = self.__control.video()
            values = video.getSupportedVideoMode()
            valueList = [_getDictKey(self.__VideoMode,val) for val in values]
        else:
            dict_name = '_' + self.__class__.__name__ + '__' + ''.join([x.title() for x in attr_name.split('_')])
            d = getattr(self,dict_name,None)
            if d:
                valueList = d.keys()

        return valueList

    ##@brief prepare an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def prepareAcq(self) :
        self.__control.prepareAcq()

    ##@brief start an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def startAcq(self) :
        self.__control.startAcq()

    ##@brief stop an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def stopAcq(self) :
        self.__control.stopAcq()

    ##@brief reset acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def reset(self) :
        self.__control.reset()
        #reapply default config
        if self.__configDefaultActiveFlag:
            config = self.__control.config()
            config.apply(self.ConfigurationDefaultName)


    ##@brief set images heaaders
    #
    @Core.DEB_MEMBER_FUNCT
    def setImageHeader(self,headers_str) :
        control = self.__control
        saving = control.saving()
        for image_header in headers_str:
            imageIdSepPos = image_header.find(self.__image_number_header_delimiter)
            imageId = int(image_header[:imageIdSepPos])
            header_str = image_header[imageIdSepPos+1:]
            deb.Param('Setting to image %d file header: %s' % (imageId,header_str))
            header_map = {}
            for line in header_str.split(self.__entry_header_delimiter) :
                token = line.split(self.__key_header_delimiter)
                key = token[0].strip()
                if not key:
                    continue
                try:
                    val = '='.join(token[1:]).strip()
                except ValueError:
                    continue
                if val.endswith(';'):
                    val = val[:-1]
                header_map[key] = val
            saving.updateFrameHeader(imageId,header_map)

    ##@brief get image data
    #
    @Core.DEB_MEMBER_FUNCT
    def getImage(self,image_id) :
        data = self.__control.ReadImage(image_id)
        self.__dataflat_cache = numpy.array(data.buffer.ravel())
        self.__dataflat_cache.dtype = numpy.uint8
        data.releaseBuffer()
        return self.__dataflat_cache

    ##@brief get image data
    #
    @Core.DEB_MEMBER_FUNCT
    def readImage(self,frame_number):

        imageType2DataArrayType = {
            Core.Bpp8 : 0 ,
            Core.Bpp10 : 1 ,
            Core.Bpp12 : 1 ,
            Core.Bpp14 : 1 ,
            Core.Bpp16 : 1,
            Core.Bpp32 : 2 ,
            Core.Bpp8S : 4 ,
            Core.Bpp10S : 5 ,
            Core.Bpp12S : 5 ,
            Core.Bpp14S : 5 ,
            Core.Bpp16S : 5,
            Core.Bpp32S : 6 ,
            }        
        image = self.__control.image()
        imageType = image.getImageType()
        dim = image.getImageDim()    
        sizes = [imageType2DataArrayType.get(imageType,"?"), dim.getSize().getWidth(), dim.getSize().getHeight()]
    
        # The DATA_ARRAY definition
        #struct {
          #unsigned int Magic= 0x44544159;
          #unsigned short Version;
          #unsigned  short HeaderLength;
          #DataArrayCategory Category;
          #DataArrayType DataType;
          #unsigned short DataEndianness;
          #unsigned short NbDim;
          #unsigned short Dim[8]
          #unsigned int DimStep[8]
        #} DataArrayHeaderStruct;

        #enum DataArrayCategory {
            #ScalarStack = 0;
            #Spectrum;
            #Image;
            #SpectrumStack;
            #ImageStack;
        #};

        #enum DataArrayType{
          #DARRAY_UINT8 = 0;
          #DARRAY_UINT16;
          #DARRAY_UINT32;
          #DARRAY_UINT64;
          #DARRAY_INT8;
          #DARRAY_INT16;
          #DARRAY_INT32;
          #DARRAY_INT64;
          #DARRAY_FLOAT32;
          #DARRAY_FLOAT64;
        #};

        #prepare the structure
        #  '>IHHHHHHHHHHHHHHIIIIIIII',
        dataheader = struct.pack(
          '<IHHIIHHHHHHHHHHHHHHHHHHIII',
          0x44544159,  				# 4bytes I  - magic number
          1,           				# 2bytes H  - version
          64,          				# 2 bytes H - header length, this header
          2,           				# 4 bytes I - category (enum)
          sizes[0],    				# 4 bytes I - data type (enum)
          0,           				# 2 bytes H - endianness
          2,           				# 2 bytes H - nb of dims
          sizes[1],sizes[2],0,0,0,0,0,0,	# 16 bytes Hx8 - dims
          1,sizes[2],0,0,0,0,0,0,    		# 16 bytes H x 8 - dimsteps
          0,0,0)    				# padding 3 x 4 bytes
        print 'readImage: frame_number = ', frame_number
        image = self.__control.ReadImage(frame_number)
        flatimage = image.buffer.ravel()
        flatimage.dtype = numpy.uint8
        
        self._datacache = dataheader+flatimage.tostring()        
        image.releaseBuffer()
        
        return ('DATA_ARRAY',  self._datacache)  
  

    ##@brief get base image data
    #
    #image before post processing
    @Core.DEB_MEMBER_FUNCT
    def getBaseImage(self,image_id) :
        data = self.__control.ReadBaseImage(image_id)
        self.__dataflat_cache = numpy.array(data.buffer.ravel())
        self.__dataflat_cache.dtype = numpy.uint8
        return self.__dataflat_cache

    ##@brief manual write image
    #
    #
    @Core.DEB_MEMBER_FUNCT
    def writeImage(self,image_id) :
        saving = self.__control.saving()
        saving.writeFrame(image_id)

    ##@brief get saturated images
    #
    #@params image_id if < 0 read the last image
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedImageCounter(self,image_id) :
        acc = self.__control.accumulation()
        saturated_image = acc.readSaturatedImageCounter(image_id)
        self.__arr_cache = []
        if saturated_image.buffer is not None:
            self.__arr_cache = numpy.array(saturated_image.buffer)
            self.__arr_cache = self.__arr_cache.ravel()
        return self.__arr_cache

    ##@brief get saturated sum counter
    #
    #@params from_image_id the starting image id
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedSumCounter(self,from_image_id) :
        acc = self.__control.accumulation()
        sumCounters = acc.readSaturatedSumCounter(from_image_id)
        returnList = []
        if sumCounters:
            number_of_counters_per_image = len(sumCounters[0])
            returnList = list(itertools.chain(*sumCounters))
            returnList.insert(0,number_of_counters_per_image)
        return returnList
    ##@brief set the mask file for saturated counters
    #
    #@params file_path the full path of mask image or '' -> unset Mask
    @Core.DEB_MEMBER_FUNCT
    def setAccSaturatedMask(self,file_path) :
        if file_path:
            f = EdfFile.EdfFile(file_path)
            d = f.GetData(0)
            data = Core.Processlib.Data()
            data.buffer = d
        else:                           # UNSET MASK
            data = Core.Processlib.Data()
        acc = self.__control.accumulation()
        acc.setMask(data)
            
#------------------------------------------------------------------
#    closeShutterManual command:
#
#    Description: Close the shutter manual
#    argout: DevVoid  
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def closeShutterManual(self):

        shutter = self.__control.shutter()
        
	if shutter.hasCapability() and shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(False)
            
#------------------------------------------------------------------
#    openShutterManual command:
#
#    Description: Open the shutter manual
#    argout: DevVoid  
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def openShutterManual(self):

        shutter = self.__control.shutter()
        
	if shutter.hasCapability() and shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(True)


    @Core.DEB_MEMBER_FUNCT
    def getPluginDeviceNameFromType(self,pluginType):
        pluginType2deviceName = dict([(x.lower().replace('deviceserver',''),y) for x,y in get_sub_devices().iteritems()])
        return pluginType2deviceName.get(pluginType,'')

#----------------------------------------------------------------------------
#                         Configuration Mgt
#----------------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def configStore(self,args):
        config_name = args.pop(0)
        config = self.__control.config()
        config.store(config_name,*args)

    @Core.DEB_MEMBER_FUNCT
    def configApply(self,config_name):
        config = self.__control.config()
        config.apply(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configPop(self,config_name):
        config = self.__control.config()
        config.pop(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configDelete(self,config_name):
        config = self.__control.config()
        config.remove(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configFileSave(self):
        config = self.__control.config()
        config.save()

    @Core.DEB_MEMBER_FUNCT
    def configFileLoad(self):
        config = self.__control.config()
        config.load()

#==================================================================
#
#    LimaCCDsClass class definition
#
#==================================================================
class LimaCCDsClass(PyTango.DeviceClass) :
    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'LimaCameraType' :
        [PyTango.DevString,
         "Camera Plugin name",[]],
        'NbProcessingThread' :
        [PyTango.DevString,
         "Number of thread for processing",[2]],
        'AccThresholdCallbackModule':
        [PyTango.DevString,
         "Plugin name file which manage threshold",[]],
        'ConfigurationFilePath' :
        [PyTango.DevString,
         "Configuration file path",[os.path.join(os.path.expanduser('~'),'lima_%s.cfg' % sys.argv[1])]],
        'ConfigurationDefaultName' :
        [PyTango.DevString,
         "Default configuration name",["default"]],
        }

    #    Command definitions
    cmd_list = {
        'openShutterManual':
        [[PyTango.DevVoid, ""],
         [PyTango.DevVoid, ""]],
        'closeShutterManual':
        [[PyTango.DevVoid, ""],
         [PyTango.DevVoid, ""]],
        'getAttrStringValueList':
        [[PyTango.DevString, "Attribute name"],
         [PyTango.DevVarStringArray, "Authorized String value list"]],
        'prepareAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'startAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'stopAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'reset':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'setImageHeader':
        [[PyTango.DevVarStringArray,"ImageId0 SEPARATOR imageHeader0,ImageId1 SEPARATOR imageHeader1..."],
         [PyTango.DevVoid,""]],
        'getImage':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarCharArray,"The data image"]],
        'getBaseImage':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarCharArray,"The base data image"]],
        'readAccSaturatedImageCounter':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarUShortArray,"The image counter"]],
        'readAccSaturatedSumCounter':
        [[PyTango.DevLong,"From image id"],
         [PyTango.DevVarLongArray,"number of result for each images,sum counter of raw image #0 of image #0,sum counter of raw image #1 of image #0,..."]],
        'setAccSaturatedMask':
         [[PyTango.DevString,"Full path of mask file"],
         [PyTango.DevVoid,""]],
        'writeImage':
        [[PyTango.DevLong,"Image id"],
         [PyTango.DevVoid,""]],
        'readImage':
        [[PyTango.DevLong,"Image id"],
         [PyTango.DevEncoded, ""]],
        'getPluginDeviceNameFromType':
        [[PyTango.DevString,"plugin type"],
         [PyTango.DevString,"device name"]],
        'configStore':
        [[PyTango.DevVarStringArray,"config name,module1,module2,...,modulen"],
         [PyTango.DevVoid,""]],
        'configApply':
        [[PyTango.DevString,"config name"],
         [PyTango.DevVoid,""]],
        'configPop':
        [[PyTango.DevString,"config name"],
         [PyTango.DevVoid,""]],
        'configDelete':
        [[PyTango.DevString,"config name"],
         [PyTango.DevVoid,""]],
        'configFileSave':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'configFileLoad':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
	}
    
    #    Attribute definitions
    attr_list = {
        'lima_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'camera_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],	 
        'camera_model':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'camera_pixelsize':
        [[PyTango.DevDouble,
          PyTango.SPECTRUM,
          PyTango.READ,2],
         {
             'label':"Pixel size:x_size, y_size",
             'unit':"meter",
             'standard unit':"meter",
             'display unit':"meter",
             'format':"%f",
             'description':"Size of the pixel in meter",
         }],
        'acq_status':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'acq_status_fault_error':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'acc_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_dead_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_live_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_saturated_active':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_saturated_threshold':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_saturated_cblevel':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_time_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_max_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'concat_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'latency_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'valid_ranges':
        [[PyTango.DevDouble,
          PyTango.SPECTRUM,
          PyTango.READ,4],
         {
             'label':"valid time ranges: min_exposure, max_exposure, min_latency, max_latency",
             'unit': "second",
             'standard unit':"second",
             'display unit':"second",
             'format':"%f",
             'description':"min_exposure, max_exposure, min_latency, max_latency",
         }],
        'acq_trigger_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'image_roi':
        [[PyTango.DevLong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,4]],
        'image_sizes':
        [[PyTango.DevULong,
          PyTango.SPECTRUM,
          PyTango.READ,4],
         {
             'label':"Image sizes:Signed, Depth, Width, Height",
             'unit':"",
             'standard unit':"",
             'display unit':"",
             'format':"%d",
             'description':"Signed ,nb bytes of depth, nb pixels of width and nb pixels of height",
         }],
        'image_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_width':
        [[PyTango.DevULong,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_height':
        [[PyTango.DevULong,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_bin':
        [[PyTango.DevULong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'image_flip':
        [[PyTango.DevBoolean,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'image_rotation':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'last_image_acquired':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'last_base_image_ready':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'last_image_ready':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'last_image_saved':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'last_counter_ready':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'ready_for_next_image':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ]],
        'ready_for_next_acq':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ]],
        'write_statistic':
        [[PyTango.DevDouble,
          PyTango.SPECTRUM,
          PyTango.READ,256]],
        'shutter_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'shutter_manual_state':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'shutter_open_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'shutter_close_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_directory':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_prefix':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_suffix':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_next_number':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_format':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_overwrite_policy':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_frame_per_file':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_common_header':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,65535]],
        'saving_header_delimiter':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,3]],
	'saving_index_format' :
	[[PyTango.DevString,
	  PyTango.SCALAR,
	  PyTango.READ_WRITE]],
        'debug_modules_possible':
         [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,len(LimaCCDs._debugModuleList)]],
        'debug_modules':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,len(LimaCCDs._debugModuleList)]],
        'debug_types_possible':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,len(LimaCCDs._debugTypeList)]],
         'debug_types':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,len(LimaCCDs._debugTypeList)]],
        'video_active':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'video_live':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'video_exposure':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'video_gain':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'video_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'video_roi':
        [[PyTango.DevLong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,4]],
        'video_bin':
        [[PyTango.DevULong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'video_last_image':
        [[PyTango.DevEncoded,
          PyTango.SCALAR,
          PyTango.READ],
         {
             'label':"the video image",
             'unit':"",
             'standard unit':"",
             'display unit':"",
             'format':"%d",
             'description':"video image as encoded",
             }],
        'video_last_image_counter':
        [[PyTango.DevLong64,
          PyTango.SCALAR,
          PyTango.READ]],
        'plugin_type_list':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,256]],
        'plugin_list':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,256]],
        'shared_memory_names':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'shared_memory_active':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'config_available_module':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,1024]],
        'config_available_name':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,1024]],
        }


def declare_camera_n_commun_to_tango_world(util) :
    for module_name in camera.__all__:
        try:
            m = __import__('camera.%s' % (module_name),None,None,'camera.%s' % (module_name))
        except ImportError:
            continue
        else:
            try:
		func = getattr(m,'get_tango_specific_class_n_device')
                specificClass,specificDevice = func()
            except AttributeError:
                pass
            else:
                util.add_TgClass(specificClass,specificDevice,specificDevice.__name__)
            try:
                func = getattr(m, 'get_taco_specific_cmd_list_n_proxy_cont')
                cmd_list, proxy_cont = func()
                TacoSpecificDict[module_name] = cmd_list, proxy_cont
            except AttributeError:
                pass

    warningFlag = False
    for module_name in plugins.__all__:
        try:
            m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
        except ImportError:
            print "Warning optional plugin %s can't be load, dependency not satisfied." % module_name
            warningFlag = True
            if verboseLevel >= 4:
                import traceback
                traceback.print_exc()
                print
            continue
        else:
            if 'Taco' in module_name:
                try:
                    func = getattr(m,'set_taco_specific_dict_n_name_cont')
                    func(TacoSpecificDict, TacoSpecificName)
                except AttributeError:
                    pass
            try:
		func = getattr(m,'get_tango_specific_class_n_device')
            except AttributeError:
                continue
            else:
                specificClass,specificDevice = func()
		util.add_TgClass(specificClass,specificDevice,specificDevice.__name__)
    if warningFlag and verboseLevel < 4:
        print "For more pulgins dependency  information start server with -v4"
        
def export_default_plugins() :
    #Post processing tango export
    util = PyTango.Util.instance()
    className2deviceName = get_sub_devices()
    masterDeviceName = className2deviceName.get('LimaCCDs',None)
    if masterDeviceName:
        beamlineName,_,cameraName = masterDeviceName.split('/')
        for module_name in plugins.__all__:
            try:
                m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
            except ImportError:
                continue
            else:
                try:
                    specificClass,specificDevice = m.get_tango_specific_class_n_device()
                except AttributeError:
                    continue

                deviceName = className2deviceName.get(specificDevice.__name__,None)
                #only create one if not exist
                if deviceName is None and specificClass and specificDevice:
                    deviceName = '%s/%s/%s' % (beamlineName,
                                               specificDevice.__name__.lower().replace('deviceserver',''),cameraName)
                    print 'create device',specificDevice.__name__,deviceName
                    try:
                        util.create_device(specificDevice.__name__,deviceName)
                    except:
                        import traceback
                        traceback.print_exc()

def _set_control_ref(ctrl_ref) :
    for module_name in plugins.__all__:
        try:
            m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
        except ImportError:
            continue
	else:
	    try:
	        func = getattr(m,"set_control_ref")
		func(ctrl_ref)
	    except AttributeError:
		continue

#============================================================================
#                                TOOLS
#============================================================================
def _getLastFileNumber(prefix,suffix,filesPath) :
    lastNumber = -1
    prefixLen = len(prefix)
    lenSuffix = len(suffix)

    for fPath in filesPath :
        fName = os.path.split(fPath)[-1]
        number = fName[prefixLen:-lenSuffix]
        try:
            number = int(number)
        except ValueError:
            continue
        else:
            if number > lastNumber:
                lastNumber = number
    return lastNumber

def _getDictKey(dict, value):
    try:
        ind = dict.values().index(value)                            
    except ValueError:
        return None
    return dict.keys()[ind]

def _getDictValue(dict, key):
    try:
        value = dict[key.upper()]
    except KeyError:
        return None
    return value

def _allowed(*args) :
    return True

def _not_allowed(*args) :
    return False

def get_sub_devices() :
    className2deviceName = {}
    #get sub devices
    fullpathExecName = sys.argv[0]
    execName = os.path.split(fullpathExecName)[-1]
    execName = os.path.splitext(execName)[0]
    personalName = '/'.join([execName,sys.argv[1]])
    dataBase = PyTango.Database()
    result = dataBase.get_device_class_list(personalName)
    for i in range(len(result.value_string) / 2) :
        class_name = result.value_string[i * 2]
        deviceName = result.value_string[i * 2 + 1]
        className2deviceName[deviceName] = class_name
    return className2deviceName

            
     
#==================================================================
#
#    LimaCCDs class main method
#
#==================================================================
def main() :
    global verboseLevel
    verboseLevel = 0
    for option in sys.argv:
        if option.startswith('-v'):
            try:
                verboseLevel = int(option[2:])
            except: pass
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(LimaCCDsClass,LimaCCDs,'LimaCCDs')
	try:
            declare_camera_n_commun_to_tango_world(py)
	except:
            print 'SEB_EXP'
            import traceback
            traceback.print_exc()
        
        U = PyTango.Util.instance()
        U.server_init()
	try:
            export_default_plugins()
	except:
            print 'SEB_EXP'
            import traceback
            traceback.print_exc()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
